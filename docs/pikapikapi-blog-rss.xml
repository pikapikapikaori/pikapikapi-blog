<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
<channel>
  <title>Pikapikapi Blog</title>
  <atom:link href="https://pikapikapikaori.github.io/pikapikapi-blog/pikapikapi-blog-rss.xml" rel="self" type="application/rss+xml" />
  <link>https://pikapikapikaori.github.io/pikapikapi-blog</link>
  <description>Pikapikapi Blog</description>
   
  <entry>
    <title><![CDATA[软件项目实践的一些思索与后期优化方向：设计、开发以及其他]]></title>
    <link>https://pikapikapikaori.github.io/pikapikapi-blog/#/archive/ITtech/SoftwareInsights-20230428</link>
    <guid isPermaLink="false">https://pikapikapikaori.github.io/pikapikapi-blog/#/archive/ITtech/SoftwareInsights-20230428</guid>
    <content type="html"><![CDATA[<h1 id="软件项目实践的一些思索与后期优化方向设计开发以及其他">软件项目实践的一些思索与后期优化方向：设计、开发以及其他</h1><blockquote><p>本文首发于个人博客<br />发表日期：2023.04.28<br />最后编辑于：{docsify-last-updated}</p></blockquote><p>大四下最后的一门课也结束了。这门课大体是由数个人组成一个小小团体进行一个小小项目从零到一的完整开发过程，不同于其他课程，这个项目要求以类似于实际开发的模式，让所有参与者都经历由需求确定、初期架构设计到中期开发、版本发布甚至于是需求变更以及迭代的完整软件开发的整个生命周期。当然其中也包括不同团队间的沟通协商。</p><p>大体而言我在其中以项目经理、架构设计、团队Leader等各种身份参与了后端的完整开发，并也作为开发者参与到了前端部分的开发任务中。个人从中确实有不少感悟，故而写此文记录。在这里主要想谈谈设计、开发的一些感想，诸如进度管理、质量把控等等可能也略有涉及。</p><h2 id="项目背景">项目背景</h2><p>大体而言这个课程项目要求做一个宠物医院的线上学习平台，主要受众大概就是即将毕业或是正在大学学习的兽医相关专业的学生。其功能简要来讲大概有这么几类：</p><ul><li>用户管理与鉴权：常规的大系统都有的功能，这里大体上就分为管理员、出题的老师和进行学习的学生三类用户。</li><li>一个完整医院的3D全景地图与导览模型：前端开发为主的功能，本文不涉及。</li><li>系统管理：要求对这个宠物医院内诸如药物、档案、收费项目、各类检查项目、住院者的信息等等各类内容进行管理，不过这个东西似乎没有在需求文档中体现出实际的意义与用处。</li><li>病例管理：大体上是需要把来医院就诊过的各类病例收集起来存储，其包括从入院诊断、具体检查到诊断结果与治疗方案等全过程的文字图片视频信息，当然也包括得的病的信息。</li><li>测试管理：由病例管理上游的疾病部分内容衍生而来。老师根据疾病生成题库，并从中选题整理为试卷。学生则参加考试进行答题。不过这部分内容似乎与虚拟宠物医院没有太大关系。</li><li>职能学习：一方面是让学生去学习疾病的相关知识（当然要看文字图片视频），一方面学生也可以通过看文字图片视频学习医院内各类角色（医生、医助等等）的具体操作内容。</li><li>数据管理：和上面提到的图片视频的存储有关。需求上还挺麻烦的，视频格式支持太多还需要进行视频的格式转换，反应到和用户的交互上来说还需要实现分块上传等功能等。</li></ul><p>尽管后文对具体业务尽量不会涉及，但姑且将背景记于这里。不难看出这个项目还是一个比较传统的要用到数据库后端前端三个维度的项目，因而后文也主要想从这三个维度的设计与开发两方面来聊聊。</p><p>项目可以参考：</p><ul><li><a href="https://github.com/SoftwareDevelopmentPractice6/virtualPetHospital-backend">后端</a></li><li><a href="https://github.com/SoftwareDevelopmentPractice6/virtualPetHospital-frontend">前端</a></li></ul><p>本博客的仓库中也保存了相关的源码，可以参考<a href="https://github.com/pikapikapikaori/pikapikapi-blog/tree/master/resource/ITtech/SoftwareInsights-20230428">这里</a>。</p><h2 id="设计">设计</h2><p>由于课程要求重各类文档，因而并没有采取如今主流的敏捷开发模式，而是采取的<a href="#RAD">RAD</a>模型。个人来讲其实并不是很习惯这个模型，一方面其由瀑布式改进而来，从某种角度上还是非常重文档和前期的设计的，对需求的变更与过程中的变化并不敏感，另一方面也是因此在开发过程中的抗风险能力也非常依赖于前期的设计以及开发过程中的质量，由此带来的风险是非常恐怖的。</p><p>总之也是因此在进行前期设计时就花了相当多的时间。然而尽管如此，初期的设计还是有着比较大的漏洞，因而也给后期开发带来了一些麻烦。这些问题大多集中在数据库设计上。</p><h3 id="数据库设计">数据库设计</h3><p>由于项目较为庞大因而一些细节的设计我也没有来得及能够去亲自把控，而是交给了同组的其他人。在这里就出了问题。上文所述的测试管理中，题库中的问题需要记录与其相关的问题类别（属于哪种病）、问题类型（单选多选）、问题内容等等。针对此负责这块内容的组员A给出了这样的设计：</p><pre class="mermaid"><code>erDiagramExam {int exam_id PKstring exam_name}Paper {int paper_id PKstring paper_nameint exam_id FKstring durationstring total_score}Question {int question_id PKstring question_contentstring question_typeint category_id FK}Category {int category_id PKstring category_name}ExamSession {int session_id PKint paper_id FKtime start_timetime end_time}StudentResult {int result_id PKint session_id FKint student_idint score}Exam ||--|| Paper : relatePaper ||--|| ExamSession : relateQuestion }o--|| Category : containsExamSession ||--o{ StudentResult : relate</code></pre><p>且不谈同学A遗漏了需要对每张卷子上包含的题目、以及每位学生在试卷上答题所做出的回答进行存储的功能，单看<code>Question</code>与<code>Category</code>两张表。乍一看虽然是挺合理的设计，然而后者的实际有效字段只有<code>category_name</code>一栏。我不否认在大型项目中这样设计的合理性，但是考虑到这个项目的规模、以及后续可能会进行的功能上的拓展，我个人看来<code>Category</code>这张表完全冗余的。</p><p>另一方面，<code>Exam</code>、<code>Paper</code>、<code>ExamSession</code>这三张一对一的表虽然也是很符合设计原则的设计，但是同样考虑到项目规模与未来可能的拓展，这三张表就算合在一起也不会对性能与吞吐量带来很大的负担。一般来讲，只有在表中有一栏以上可能包含大量空值的情况下，或是某一些栏可能被频繁更新时，一对一关系的设计才相对合理。而在当前的情形中，这样的设计则是给后期撰写<code>SQL</code>与开发上带来了巨大的麻烦。且不谈数据的整合与处理，仅仅是外键的存在就已经带来了巨大的麻烦。这也直接导致了在后期初始化数据<code>SQL</code>撰写上耗费了大量Debug的时间，在开发的编码中也需要增加大量检测外键存在性的不必要代码。</p><h3 id="后端架构设计">后端架构设计</h3><p>初期设计时我就已经敲定了<a href="#微服务">微服务</a>的架构。通常，微服务确实不适合于本项目这样的小型项目：配置麻烦、DevOps麻烦，等等。此外，大型项目中服务间数据一致性以及安全性都是非常棘手且关键的问题。</p><p>不过事实上，我其实很看重松散耦合这一点。其给后期开发与迭代过程中带来的自由度是相当大的。前述的问题，如配置、DevOps的确相对棘手，不过包含公用模块、各类插件的配置在初期完成后便一了百了，运维上利用Docker与统一的脚本进行自动化管理也是一经配置后就极易使用的，并没有给开发人员带来很高的成本。倘若有购买服务器配置Jenkins进行更多的自动化的话，相关成本应该还能进一步降低。</p><p>实践中，jacoco、spotless、公共模块的配置实质上也仅仅耗费了我半天的时间，而后期部署时自动化测试脚本的编写仅仅耗费了我两个小时不到的时间。接口测试上所花费的时间略多一点，不过由于接口测试脚本基本是直接由swagger生成的，因而也没有耗费太多的成本。</p><p>相较于这些仅局限于初期和末期的麻烦而言，微服务架构带来的好处是实打实巨大的。数据库与模块的分离带来的是各模块开发的高独立性以及运行时的高可用性。前文所提到的数据库尽管经常会碰到组员产生的Bug，但分离的数据库使得其余的几个模块并没有受到影响从而能够很顺利的进行开发。另一方面，后端模块的分离使得几个模块都能够被快速地开发出来，也因此能够较早地将接口给到前端，从而留出了大量可用于迭代的时间。产生缺陷时查找定位的范围仅仅在自身的子系统内，因而定位缺陷的成本也略有降低。而最最重要的，由于模块间的松散耦合，即使一个服务失败其他服务也能够继续工作，这给开发与测试都带来了相当程度上的便捷。</p><p>更具体的，微服务给实践中的开发带来了巨大的便捷性。我在项目中大概采取了下图的架构：</p><pre class="mermaid"><code>flowchart LR    subgraph backend        subgraph modules            direction TB            subgraph module 1                direction LR                entity1 --&gt; dao1 --&gt; service1 --&gt; controller1            end            subgraph module 2                direction LR                entity2 --&gt; dao2 --&gt; service2 --&gt; controller2            end            subgraph module 3                direction LR                entity3 --&gt; dao3 --&gt; service3 --&gt; controller3            end            subgraph module 4                direction LR                entity4 --&gt; dao4 --&gt; service4 --&gt; controller4            end        end        subgraph intermediator            direction LR            servicei --&gt; controlleri        end        controller1 --&gt; servicei        controller2 --&gt; servicei        controller3 --&gt; servicei        controller4 --&gt; servicei    end    subgraph database        databse1 --&gt; entity1        databse2 --&gt; entity2        databse3 --&gt; entity3        databse4 --&gt; entity4    end    controlleri --&gt; frontend</code></pre><p>作为微服务而言其实也是非常常见与合理的架构。中间层充当网关的角色被外部服务（前端）统一调用，其内部则再根据具体的调用请求来选择合适的服务进行通信，并将数据进行处理后转发给外部服务。在实践中，前端组与后端组同时开发，需求细节与开发细节还不明了的情况下，接口的内容与种类尽管可以大体确定，但具体的数据内容与种类等都是难以确定的。因而，利用中间层也即网关这一角色，接口确定的难题得以被解决。前后端可以先按照自己的想法对接口进行设计与模拟，当有一定的进度、对接口需求更加明确时再利用中间层进行数据的整合与处理，从而节约了大量沟通与修改的时间。</p><pre class="mermaid"><code>sequenceDiagram    Frontend-&gt;&gt;+Intermediator: Request    Intermediator-&gt;&gt;+Module: Processed Request    Module--&gt;&gt;-Intermediator: Response    Intermediator--&gt;&gt;-Frontend: Processed Response</code></pre><p>实践上，数据的转发与整合可以由后端的网关接管，也可以由前端利用nodejs来开发，无论哪种都是非常灵活的。事实上，nodejs构建的中间层或称node层的出现，就是为了让前后端都更关注于业务本身。尽管层数的增加可能会给性能带来一些影响，然而这与开发效率所节省的成本相比是微乎其微的。由过去后端渲染html发送给浏览器的前后端不分离，到前后端分离开发再到中间层的进化，我想这是一个相当自然的过程，也非常值得去学习与应用。</p><p>此外，采取微服务架构，后期的扩展性也是相当高的。一方面，需要增加新业务时可以直接以模块为单位进行添加，而不需要再去对原有代码进行改动。另一方面，甚至也可以将同一服务运行在多台服务器上，并利用Eureka、Ribbon等等组件进行负载均衡与健康检查的功能，从而能够进一步提升可用性与性能，这些都是单体应用难以带来的好处。</p><p>当然，微服务的思想也能直接应用到前端上，也就是前些年提出的<a href="#微前端">微前端</a>的思想。似乎前端组也有利用这一思想进行开发，不过本文就先不作赘述了。</p><h2 id="开发">开发</h2><h3 id="后端开发仍存在的问题">后端开发仍存在的问题</h3><p>开发上后端直接采用了SpringBoot的四层架构，基本上实现了增删改查四类功能。同时，调数据库方面使用了JPA。</p><p>需求上，为了满足全字段搜索、以及较简单的增删改功能，考虑到开发上的便捷性，查询相关的业务逻辑大体都是采取了下面的写法：</p><div class="sourceCode" id="cb4"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">public</span> JSONObject <span class="fu">getFeature</span>(</span><span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>        <span class="bu">Integer</span> funcId,</span><span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>        <span class="bu">String</span> funcName,</span><span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>        <span class="bu">String</span> funcDescription,</span><span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>        <span class="bu">String</span> funcFlow,</span><span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>        <span class="bu">String</span> funcRole,</span><span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>        <span class="bu">String</span> funcTool,</span><span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>        <span class="bu">String</span> roomName) {</span><span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>    JSONObject res = <span class="kw">new</span> <span class="fu">JSONObject</span>();</span><span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>    res.<span class="fu">put</span>(</span><span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>            Constants.<span class="fu">featureList</span>,</span><span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>            JSONObject.<span class="fu">parseArray</span>(JSON.<span class="fu">toJSONString</span>(featureRepository.<span class="fu">findAll</span>().<span class="fu">stream</span>()</span><span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>                    .<span class="fu">filter</span>(feature -&gt; SearchJudgeHelper.<span class="fu">softEquals</span>(funcName, feature.<span class="fu">getFuncName</span>())</span><span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>                            &amp;&amp; SearchJudgeHelper.<span class="fu">softIncludes</span>(funcDescription, feature.<span class="fu">getFuncDescription</span>())</span><span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>                            &amp;&amp; SearchJudgeHelper.<span class="fu">softIncludes</span>(funcFlow, feature.<span class="fu">getFuncFlow</span>())</span><span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>                            &amp;&amp; SearchJudgeHelper.<span class="fu">softIncludes</span>(funcRole, feature.<span class="fu">getFuncRole</span>())</span><span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>                            &amp;&amp; SearchJudgeHelper.<span class="fu">softEquals</span>(funcTool, feature.<span class="fu">getFuncTool</span>())</span><span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>                            &amp;&amp; SearchJudgeHelper.<span class="fu">softEquals</span>(</span><span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a>                                    roomName, feature.<span class="fu">getFeatureRoom</span>().<span class="fu">getRoomName</span>())</span><span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a>                            &amp;&amp; SearchJudgeHelper.<span class="fu">softEquals</span>(funcId, feature.<span class="fu">getFuncId</span>()))</span><span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a>                    .<span class="fu">collect</span>(Collectors.<span class="fu">toList</span>()))));</span><span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a>    <span class="kw">return</span> ResponseHelper.<span class="fu">constructSuccessResponse</span>(res);</span><span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a>}</span></code></pre></div><p>先说查询逻辑。为了少写<code>SQL</code>因而这里是直接调用了JPA的<code>findAll</code>方法，随后利用<code>Java</code>的流函数对其进行遍历筛选，由此得到目标结果以返回。判断相等或包含的方法由自建类进行处理，以满足空数值的比较操作，例如：</p><div class="sourceCode" id="cb5"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">public</span> <span class="dt">static</span> <span class="bu">Boolean</span> <span class="fu">softEquals</span>(<span class="bu">String</span> toBeJudged, <span class="bu">String</span> referencedValue) {</span><span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    <span class="kw">try</span> {</span><span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>        <span class="kw">return</span> (Objects.<span class="fu">equals</span>(toBeJudged, <span class="kw">null</span>) || Objects.<span class="fu">equals</span>(toBeJudged, <span class="st">&quot;&quot;</span>))</span><span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>                ? <span class="kw">true</span></span><span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>                : Objects.<span class="fu">equals</span>(referencedValue, <span class="bu">URLDecoder</span>.<span class="fu">decode</span>(toBeJudged, Constants.<span class="fu">UTF8</span>));</span><span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>    } <span class="kw">catch</span> (<span class="bu">UnsupportedEncodingException</span> e) {</span><span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>        <span class="kw">return</span> <span class="kw">false</span>;</span><span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>    }</span><span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>}</span></code></pre></div><p>小型项目中这样的写法大体上是没什么问题的，但如果遇上较大的项目这样的写法绝对会出很大的问题。一来，论谁都能看出的遍历查询的性能问题，在十万级别数据量下大概就能有很直观的感受了，这一工作本来应该在数据库中利用索引来优化解决。二来，大量的吞吐量给服务器带来了IO上巨大负担。其潜在的风险是难以估量的。</p><p>为了在满足需求的基础上尽可能简化开发上的工作量（即少写<code>SQL</code>与对应的函数），我目前的想法是利用正则表达式（例如MySQL中的<code>REGEXP</code>关键字）进行查询，由此将查询的相关工作返还给数据库。利用数据库内部的索引等机制对查询进行优化（MySQL内部索引的B+树能带来数倍的性能），借此来消除服务器的负担。借由这一方法全字段搜索可以通过唯一的一条<code>SQL</code>来实现，也符合尽量不写<code>SQL</code>的原则。</p><div class="sourceCode" id="cb6"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="co">// Dao层</span></span><span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="at">@Query</span>(value = <span class="st">&quot;SELECT f.* FROM Feature f WHERE (f.name REGEXP :funcNameRegExp) AND (f.description REGEXP :funcDescriptionRegExp)&quot;</span>, nativeQuery = <span class="kw">true</span>)</span><span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="bu">ArrayList</span>&lt;Feature&gt; <span class="fu">findFeatureByRegExp</span>(<span class="at">@Param</span>(<span class="st">&quot;funcNameRegExp&quot;</span>) <span class="bu">String</span> funcNameRegExp, <span class="at">@Param</span>(<span class="st">&quot;funcDescriptionRegExp&quot;</span>) <span class="bu">String</span> funcDescriptionRegExp);</span><span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a></span><span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="co">// Service层</span></span><span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a><span class="kw">public</span> JSONObject <span class="fu">getFeature</span>(</span><span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>        <span class="bu">String</span> funcName,</span><span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>        <span class="bu">String</span> funcDescription) {</span><span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>    <span class="bu">String</span> funcNameRegExp = funcName;</span><span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>    <span class="bu">String</span> funcDescriptionRegExp =  <span class="st">&quot;^&quot;</span> + funcName + <span class="st">&quot;$&quot;</span>;</span><span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>    JSONObject res = <span class="kw">new</span> <span class="fu">JSONObject</span>();</span><span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>    res.<span class="fu">put</span>(</span><span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>            Constants.<span class="fu">featureList</span>,</span><span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>            JSONObject.<span class="fu">parseArray</span>(JSON.<span class="fu">toJSONString</span>(featureRepository.<span class="fu">findFeatureByRegExp</span>(funcNameRegExp, funcDescriptionRegExp))));</span><span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>    <span class="kw">return</span> ResponseHelper.<span class="fu">constructSuccessResponse</span>(res);</span><span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a>}</span></code></pre></div><p>再说增删改。项目中这些功能的实现大体如下：</p><div class="sourceCode" id="cb7"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>\\ 增</span><span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="kw">public</span> JSONObject <span class="fu">addExamine</span>(<span class="bu">String</span> examineName, <span class="dt">double</span> examinePrice, <span class="bu">String</span> roomName) {</span><span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>    <span class="bu">List</span>&lt;Examine&gt; targetExamineList = examineRepository.<span class="fu">findAll</span>().<span class="fu">stream</span>()</span><span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>            .<span class="fu">filter</span>(examine -&gt; Objects.<span class="fu">equals</span>(examine.<span class="fu">getExamineName</span>(), examineName))</span><span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>            .<span class="fu">collect</span>(Collectors.<span class="fu">toList</span>());</span><span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a></span><span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>    <span class="kw">if</span> (Objects.<span class="fu">equals</span>(targetExamineList.<span class="fu">size</span>(), <span class="dv">0</span>)) {</span><span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>        Optional&lt;Room&gt; targetRoomOptional = roomRepository.<span class="fu">findById</span>(roomName);</span><span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a></span><span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>        <span class="kw">if</span> (targetRoomOptional.<span class="fu">isEmpty</span>()) {</span><span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>            <span class="kw">return</span> ResponseHelper.<span class="fu">constructFailedResponse</span>(ResponseHelper.<span class="fu">requestErrorCode</span>);</span><span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>        } <span class="kw">else</span> {</span><span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a>            Examine newExamine = <span class="kw">new</span> <span class="fu">Examine</span>();</span><span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a>            newExamine.<span class="fu">setExamineName</span>(examineName);</span><span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a>            newExamine.<span class="fu">setExaminePrice</span>(examinePrice);</span><span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a>            newExamine.<span class="fu">setExamineRoom</span>(targetRoomOptional.<span class="fu">get</span>());</span><span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a></span><span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a>            Examine addedExamine = examineRepository.<span class="fu">saveAndFlush</span>(newExamine);</span><span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a></span><span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a>            <span class="kw">return</span> ResponseHelper.<span class="fu">constructSuccessResponse</span>(addedExamine);</span><span id="cb7-21"><a href="#cb7-21" aria-hidden="true"></a>        }</span><span id="cb7-22"><a href="#cb7-22" aria-hidden="true"></a>    } <span class="kw">else</span> {</span><span id="cb7-23"><a href="#cb7-23" aria-hidden="true"></a>        <span class="kw">return</span> ResponseHelper.<span class="fu">constructFailedResponse</span>(ResponseHelper.<span class="fu">requestErrorCode</span>);</span><span id="cb7-24"><a href="#cb7-24" aria-hidden="true"></a>    }</span><span id="cb7-25"><a href="#cb7-25" aria-hidden="true"></a>}</span><span id="cb7-26"><a href="#cb7-26" aria-hidden="true"></a></span><span id="cb7-27"><a href="#cb7-27" aria-hidden="true"></a>\\ 改</span><span id="cb7-28"><a href="#cb7-28" aria-hidden="true"></a><span class="kw">public</span> JSONObject <span class="fu">updateExamine</span>(<span class="dt">int</span> examineId, <span class="bu">String</span> examineName, <span class="dt">double</span> examinePrice, <span class="bu">String</span> roomName) {</span><span id="cb7-29"><a href="#cb7-29" aria-hidden="true"></a>    Optional&lt;Examine&gt; targetExamineOptional = examineRepository.<span class="fu">findById</span>(examineId);</span><span id="cb7-30"><a href="#cb7-30" aria-hidden="true"></a></span><span id="cb7-31"><a href="#cb7-31" aria-hidden="true"></a>    <span class="kw">if</span> (targetExamineOptional.<span class="fu">isEmpty</span>()) {</span><span id="cb7-32"><a href="#cb7-32" aria-hidden="true"></a>        <span class="kw">return</span> ResponseHelper.<span class="fu">constructFailedResponse</span>(ResponseHelper.<span class="fu">requestErrorCode</span>);</span><span id="cb7-33"><a href="#cb7-33" aria-hidden="true"></a>    } <span class="kw">else</span> {</span><span id="cb7-34"><a href="#cb7-34" aria-hidden="true"></a></span><span id="cb7-35"><a href="#cb7-35" aria-hidden="true"></a>        <span class="bu">List</span>&lt;Examine&gt; targetExamineList = examineRepository.<span class="fu">findAll</span>().<span class="fu">stream</span>()</span><span id="cb7-36"><a href="#cb7-36" aria-hidden="true"></a>                .<span class="fu">filter</span>(examine -&gt; Objects.<span class="fu">equals</span>(examine.<span class="fu">getExamineName</span>(), examineName)</span><span id="cb7-37"><a href="#cb7-37" aria-hidden="true"></a>                        &amp;&amp; !Objects.<span class="fu">equals</span>(examine.<span class="fu">getExamineId</span>(), examineId))</span><span id="cb7-38"><a href="#cb7-38" aria-hidden="true"></a>                .<span class="fu">collect</span>(Collectors.<span class="fu">toList</span>());</span><span id="cb7-39"><a href="#cb7-39" aria-hidden="true"></a></span><span id="cb7-40"><a href="#cb7-40" aria-hidden="true"></a>        Optional&lt;Room&gt; targetRoomOptional = roomRepository.<span class="fu">findById</span>(roomName);</span><span id="cb7-41"><a href="#cb7-41" aria-hidden="true"></a></span><span id="cb7-42"><a href="#cb7-42" aria-hidden="true"></a>        <span class="kw">if</span> (targetRoomOptional.<span class="fu">isEmpty</span>() || !Objects.<span class="fu">equals</span>(targetExamineList.<span class="fu">size</span>(), <span class="dv">0</span>)) {</span><span id="cb7-43"><a href="#cb7-43" aria-hidden="true"></a>            <span class="kw">return</span> ResponseHelper.<span class="fu">constructFailedResponse</span>(ResponseHelper.<span class="fu">requestErrorCode</span>);</span><span id="cb7-44"><a href="#cb7-44" aria-hidden="true"></a>        } <span class="kw">else</span> {</span><span id="cb7-45"><a href="#cb7-45" aria-hidden="true"></a>            Examine targetExamine = targetExamineOptional.<span class="fu">get</span>();</span><span id="cb7-46"><a href="#cb7-46" aria-hidden="true"></a>            targetExamine.<span class="fu">setExamineName</span>(examineName);</span><span id="cb7-47"><a href="#cb7-47" aria-hidden="true"></a>            targetExamine.<span class="fu">setExaminePrice</span>(examinePrice);</span><span id="cb7-48"><a href="#cb7-48" aria-hidden="true"></a>            targetExamine.<span class="fu">setExamineRoom</span>(targetRoomOptional.<span class="fu">get</span>());</span><span id="cb7-49"><a href="#cb7-49" aria-hidden="true"></a></span><span id="cb7-50"><a href="#cb7-50" aria-hidden="true"></a>            Examine updatedExamine = examineRepository.<span class="fu">saveAndFlush</span>(targetExamine);</span><span id="cb7-51"><a href="#cb7-51" aria-hidden="true"></a></span><span id="cb7-52"><a href="#cb7-52" aria-hidden="true"></a>            <span class="kw">return</span> ResponseHelper.<span class="fu">constructSuccessResponse</span>(updatedExamine);</span><span id="cb7-53"><a href="#cb7-53" aria-hidden="true"></a>        }</span><span id="cb7-54"><a href="#cb7-54" aria-hidden="true"></a>    }</span><span id="cb7-55"><a href="#cb7-55" aria-hidden="true"></a>}</span><span id="cb7-56"><a href="#cb7-56" aria-hidden="true"></a></span><span id="cb7-57"><a href="#cb7-57" aria-hidden="true"></a>\\ 删</span><span id="cb7-58"><a href="#cb7-58" aria-hidden="true"></a><span class="kw">public</span> JSONObject <span class="fu">deleteExamine</span>(<span class="dt">int</span> examineId) {</span><span id="cb7-59"><a href="#cb7-59" aria-hidden="true"></a>    Optional&lt;Examine&gt; targetExamineOptional = examineRepository.<span class="fu">findById</span>(examineId);</span><span id="cb7-60"><a href="#cb7-60" aria-hidden="true"></a></span><span id="cb7-61"><a href="#cb7-61" aria-hidden="true"></a>    <span class="kw">if</span> (targetExamineOptional.<span class="fu">isEmpty</span>()) {</span><span id="cb7-62"><a href="#cb7-62" aria-hidden="true"></a>        <span class="kw">return</span> ResponseHelper.<span class="fu">constructFailedResponse</span>(ResponseHelper.<span class="fu">requestErrorCode</span>);</span><span id="cb7-63"><a href="#cb7-63" aria-hidden="true"></a>    } <span class="kw">else</span> {</span><span id="cb7-64"><a href="#cb7-64" aria-hidden="true"></a>        examineRepository.<span class="fu">deleteById</span>(examineId);</span><span id="cb7-65"><a href="#cb7-65" aria-hidden="true"></a></span><span id="cb7-66"><a href="#cb7-66" aria-hidden="true"></a>        <span class="kw">if</span> (examineRepository.<span class="fu">findById</span>(examineId).<span class="fu">isEmpty</span>()) {</span><span id="cb7-67"><a href="#cb7-67" aria-hidden="true"></a>            <span class="kw">return</span> ResponseHelper.<span class="fu">constructSuccessResponse</span>(targetExamineOptional.<span class="fu">get</span>());</span><span id="cb7-68"><a href="#cb7-68" aria-hidden="true"></a>        } <span class="kw">else</span> {</span><span id="cb7-69"><a href="#cb7-69" aria-hidden="true"></a>            <span class="kw">return</span> ResponseHelper.<span class="fu">constructFailedResponse</span>(ResponseHelper.<span class="fu">requestErrorCode</span>);</span><span id="cb7-70"><a href="#cb7-70" aria-hidden="true"></a>        }</span><span id="cb7-71"><a href="#cb7-71" aria-hidden="true"></a>    }</span><span id="cb7-72"><a href="#cb7-72" aria-hidden="true"></a>}</span></code></pre></div><p>说实话每个表增删改查写一遍还是挺繁琐的，毕竟业务逻辑上太过类似了。基本上都是这样的逻辑：</p><ul><li>增：查询重复数据存在情况<span class="math inline">→</span>查外键存在情况<span class="math inline">→</span>插入数据。</li><li>改：查自身数据存在情况<span class="math inline">→</span>查询重复数据存在情况<span class="math inline">→</span>查外键存在情况<span class="math inline">→</span>插入数据。</li><li>删：直接调用JPA的<code>deleteById</code>方法。</li></ul><p>这里的如果需要重构可以考虑利用<a href="#java反射机制"><code>Java</code>反射机制</a>。事实上，项目末期时根据前端需求增加的根据数据Id查询功能就是利用这一机制写的。</p><div class="sourceCode" id="cb8"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">public</span> <span class="kw">class</span> GeneralService {</span><span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>    <span class="at">@Autowired</span></span><span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>    <span class="kw">private</span> RoomRepository roomRepository;</span><span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a></span><span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>    <span class="at">@Autowired</span></span><span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>    <span class="kw">private</span> FeatureRepository featureRepository;</span><span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a></span><span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>    <span class="at">@Autowired</span></span><span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>    <span class="kw">private</span> AdmissionRepository admissionRepository;</span><span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a></span><span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>    <span class="at">@Autowired</span></span><span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a>    <span class="kw">private</span> ArchiveRepository archiveRepository;</span><span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a></span><span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a>    <span class="at">@Autowired</span></span><span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a>    <span class="kw">private</span> ChargeRepository chargeRepository;</span><span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a></span><span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a>    <span class="at">@Autowired</span></span><span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a>    <span class="kw">private</span> ExamineRepository examineRepository;</span><span id="cb8-19"><a href="#cb8-19" aria-hidden="true"></a></span><span id="cb8-20"><a href="#cb8-20" aria-hidden="true"></a>    <span class="at">@Autowired</span></span><span id="cb8-21"><a href="#cb8-21" aria-hidden="true"></a>    <span class="kw">private</span> MedicineRepository medicineRepository;</span><span id="cb8-22"><a href="#cb8-22" aria-hidden="true"></a></span><span id="cb8-23"><a href="#cb8-23" aria-hidden="true"></a>    <span class="kw">public</span> JSONObject <span class="fu">getDataById</span>(<span class="bu">String</span> tableName, <span class="dt">int</span> id) <span class="kw">throws</span> <span class="bu">Exception</span> {</span><span id="cb8-24"><a href="#cb8-24" aria-hidden="true"></a>        <span class="bu">Class</span>&lt;?&gt; dataDaoClass = <span class="bu">Class</span>.<span class="fu">forName</span>(</span><span id="cb8-25"><a href="#cb8-25" aria-hidden="true"></a>                Constants.<span class="fu">projectPackageName</span> + <span class="st">&quot;.&quot;</span> + Constants.<span class="fu">systemModulePackageName</span> + <span class="st">&quot;.&quot;</span></span><span id="cb8-26"><a href="#cb8-26" aria-hidden="true"></a>                        + Constants.<span class="fu">daoClassPackageName</span></span><span id="cb8-27"><a href="#cb8-27" aria-hidden="true"></a>                        + <span class="st">&quot;.&quot;</span> + tableName</span><span id="cb8-28"><a href="#cb8-28" aria-hidden="true"></a>                        + Constants.<span class="fu">daoClassSuffix</span>,</span><span id="cb8-29"><a href="#cb8-29" aria-hidden="true"></a>                <span class="kw">true</span>,</span><span id="cb8-30"><a href="#cb8-30" aria-hidden="true"></a>                <span class="bu">Thread</span>.<span class="fu">currentThread</span>().<span class="fu">getContextClassLoader</span>().<span class="fu">getParent</span>());</span><span id="cb8-31"><a href="#cb8-31" aria-hidden="true"></a></span><span id="cb8-32"><a href="#cb8-32" aria-hidden="true"></a>        <span class="bu">Method</span> getByIdMethod = <span class="kw">null</span>;</span><span id="cb8-33"><a href="#cb8-33" aria-hidden="true"></a></span><span id="cb8-34"><a href="#cb8-34" aria-hidden="true"></a>        <span class="kw">for</span> (<span class="bu">Method</span> classMethods : dataDaoClass.<span class="fu">getMethods</span>()) {</span><span id="cb8-35"><a href="#cb8-35" aria-hidden="true"></a>            <span class="kw">if</span> (Objects.<span class="fu">equals</span>(classMethods.<span class="fu">getName</span>(), Constants.<span class="fu">findByIdMethodName</span>)) {</span><span id="cb8-36"><a href="#cb8-36" aria-hidden="true"></a>                getByIdMethod = classMethods;</span><span id="cb8-37"><a href="#cb8-37" aria-hidden="true"></a>            }</span><span id="cb8-38"><a href="#cb8-38" aria-hidden="true"></a>        }</span><span id="cb8-39"><a href="#cb8-39" aria-hidden="true"></a></span><span id="cb8-40"><a href="#cb8-40" aria-hidden="true"></a>        <span class="kw">for</span> (<span class="bu">Field</span> selfField : <span class="kw">this</span>.<span class="fu">getClass</span>().<span class="fu">getDeclaredFields</span>()) {</span><span id="cb8-41"><a href="#cb8-41" aria-hidden="true"></a>            <span class="kw">if</span> (Objects.<span class="fu">equals</span>(selfField.<span class="fu">getType</span>().<span class="fu">getName</span>(), dataDaoClass.<span class="fu">getName</span>())) {</span><span id="cb8-42"><a href="#cb8-42" aria-hidden="true"></a>                Optional&lt;?&gt; getIdRes = (Optional&lt;?&gt;) getByIdMethod.<span class="fu">invoke</span>(selfField.<span class="fu">get</span>(<span class="kw">this</span>), id);</span><span id="cb8-43"><a href="#cb8-43" aria-hidden="true"></a></span><span id="cb8-44"><a href="#cb8-44" aria-hidden="true"></a>                <span class="kw">if</span> (getIdRes.<span class="fu">isEmpty</span>()) {</span><span id="cb8-45"><a href="#cb8-45" aria-hidden="true"></a>                    <span class="kw">return</span> ResponseHelper.<span class="fu">constructFailedResponse</span>(ResponseHelper.<span class="fu">requestErrorCode</span>);</span><span id="cb8-46"><a href="#cb8-46" aria-hidden="true"></a>                } <span class="kw">else</span> {</span><span id="cb8-47"><a href="#cb8-47" aria-hidden="true"></a>                    <span class="kw">return</span> ResponseHelper.<span class="fu">constructSuccessResponse</span>(getIdRes.<span class="fu">get</span>());</span><span id="cb8-48"><a href="#cb8-48" aria-hidden="true"></a>                }</span><span id="cb8-49"><a href="#cb8-49" aria-hidden="true"></a>            }</span><span id="cb8-50"><a href="#cb8-50" aria-hidden="true"></a>        }</span><span id="cb8-51"><a href="#cb8-51" aria-hidden="true"></a></span><span id="cb8-52"><a href="#cb8-52" aria-hidden="true"></a>        <span class="kw">return</span> ResponseHelper.<span class="fu">constructFailedResponse</span>(ResponseHelper.<span class="fu">requestErrorCode</span>);</span><span id="cb8-53"><a href="#cb8-53" aria-hidden="true"></a>    }</span><span id="cb8-54"><a href="#cb8-54" aria-hidden="true"></a>}</span></code></pre></div><p>事实上，删除功能可以直接套用这一写法。当然，在上面的<code>getDataById</code>方法中查找<code>Method</code>与<code>Field</code>的逻辑也可以进一步进行优化：</p><div class="sourceCode" id="cb9"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">public</span> <span class="bu">Class</span>&lt;JPARepository&gt; <span class="fu">getDataDaoClassByTableName</span> (<span class="bu">String</span> tableName) <span class="kw">throws</span> <span class="bu">Exception</span> {</span><span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>    <span class="kw">return</span> <span class="bu">Class</span>.<span class="fu">forName</span>(</span><span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>            Constants.<span class="fu">projectPackageName</span> + <span class="st">&quot;.&quot;</span> + Constants.<span class="fu">systemModulePackageName</span> + <span class="st">&quot;.&quot;</span></span><span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>                    + Constants.<span class="fu">daoClassPackageName</span></span><span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>                    + <span class="st">&quot;.&quot;</span> + tableName</span><span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>                    + Constants.<span class="fu">daoClassSuffix</span>,</span><span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>            <span class="kw">true</span>,</span><span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>            <span class="bu">Thread</span>.<span class="fu">currentThread</span>().<span class="fu">getContextClassLoader</span>().<span class="fu">getParent</span>());</span><span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>}</span><span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a></span><span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a><span class="kw">public</span> JSONObject <span class="fu">getDataById</span>(<span class="bu">String</span> tableName, <span class="dt">int</span> id) <span class="kw">throws</span> <span class="bu">Exception</span> {</span><span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>    <span class="bu">Class</span>&lt;?&gt; dataDaoClass = <span class="kw">this</span>.<span class="fu">getDataDaoClassByTableName</span>(tableName);</span><span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a>    <span class="bu">Method</span> getByIdMethod = dataDaoClass.<span class="fu">getMethod</span>(Constants.<span class="fu">findByIdMethodName</span>, <span class="bu">Integer</span>.<span class="fu">class</span>);</span><span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a>    <span class="bu">Field</span> selfField = <span class="kw">this</span>.<span class="fu">getClass</span>().<span class="fu">getDeclaredField</span>(tableName.<span class="fu">toFirstCharLowerCase</span>());</span><span id="cb9-15"><a href="#cb9-15" aria-hidden="true"></a></span><span id="cb9-16"><a href="#cb9-16" aria-hidden="true"></a>    Optional&lt;?&gt; getIdRes = (Optional&lt;?&gt;) getByIdMethod.<span class="fu">invoke</span>(selfField.<span class="fu">get</span>(<span class="kw">this</span>), id);</span><span id="cb9-17"><a href="#cb9-17" aria-hidden="true"></a></span><span id="cb9-18"><a href="#cb9-18" aria-hidden="true"></a>    <span class="kw">return</span> getIdRes.<span class="fu">isEmpty</span>() ? ResponseHelper.<span class="fu">constructFailedResponse</span>(ResponseHelper.<span class="fu">requestErrorCode</span>) : ResponseHelper.<span class="fu">constructSuccessResponse</span>(getIdRes.<span class="fu">get</span>());</span><span id="cb9-19"><a href="#cb9-19" aria-hidden="true"></a>}</span><span id="cb9-20"><a href="#cb9-20" aria-hidden="true"></a></span><span id="cb9-21"><a href="#cb9-21" aria-hidden="true"></a><span class="kw">public</span> JSONObject <span class="fu">deleteDataById</span>(<span class="bu">String</span> tableName, <span class="dt">int</span> id) <span class="kw">throws</span> <span class="bu">Exception</span> {</span><span id="cb9-22"><a href="#cb9-22" aria-hidden="true"></a>    JSONObject getDataByIdRes = <span class="kw">this</span>.<span class="fu">getDataById</span>(tableName, id);</span><span id="cb9-23"><a href="#cb9-23" aria-hidden="true"></a></span><span id="cb9-24"><a href="#cb9-24" aria-hidden="true"></a>    <span class="co">// 表内查询无数据</span></span><span id="cb9-25"><a href="#cb9-25" aria-hidden="true"></a>    <span class="kw">if</span> (<span class="bu">Object</span>.<span class="fu">equals</span>(getDataByIdRes.<span class="fu">data</span>, <span class="kw">null</span>)) {</span><span id="cb9-26"><a href="#cb9-26" aria-hidden="true"></a>        <span class="kw">return</span> getDataByIdRes;</span><span id="cb9-27"><a href="#cb9-27" aria-hidden="true"></a>    }</span><span id="cb9-28"><a href="#cb9-28" aria-hidden="true"></a></span><span id="cb9-29"><a href="#cb9-29" aria-hidden="true"></a>    <span class="bu">Class</span>&lt;?&gt; dataDaoClass = <span class="kw">this</span>.<span class="fu">getDataDaoClassByTableName</span>(tableName);</span><span id="cb9-30"><a href="#cb9-30" aria-hidden="true"></a>    <span class="bu">Method</span> deleteByIdMethod = dataDaoClass.<span class="fu">getMethod</span>(Constants.<span class="fu">deleteByIdMethodName</span>, <span class="bu">Integer</span>.<span class="fu">class</span>);</span><span id="cb9-31"><a href="#cb9-31" aria-hidden="true"></a>    <span class="bu">Field</span> selfField = <span class="kw">this</span>.<span class="fu">getClass</span>().<span class="fu">getDeclaredField</span>(tableName.<span class="fu">toFirstCharLowerCase</span>());</span><span id="cb9-32"><a href="#cb9-32" aria-hidden="true"></a></span><span id="cb9-33"><a href="#cb9-33" aria-hidden="true"></a>    deleteByIdMethod.<span class="fu">invoke</span>(selfField.<span class="fu">get</span>(<span class="kw">this</span>), id);</span><span id="cb9-34"><a href="#cb9-34" aria-hidden="true"></a></span><span id="cb9-35"><a href="#cb9-35" aria-hidden="true"></a>    <span class="kw">return</span> ResponseHelper.<span class="fu">constructSuccessResponse</span>(getDataByIdRes.<span class="fu">get</span>());</span><span id="cb9-36"><a href="#cb9-36" aria-hidden="true"></a>}</span></code></pre></div><p>为了进一步简化开发工作量与代码逻辑，可以考虑先创建公共类：<code>BaseEntity</code>与<code>BaseRepository</code>，使得实体类继承前者，对应的<code>dao</code>类继承后者。</p><p>对于增改功能而言，业务逻辑中唯二的区别在于判断重复条件与判断外键存在逻辑这两项。可以考虑抽象成统一的公共方法，通过接收可变个数个参数构成的List来进行判断。更具体的，其可能是下面的实现形式：</p><div class="sourceCode" id="cb10"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">public</span> JSONObject <span class="fu">updateDataById</span>(</span><span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>    <span class="bu">String</span> tableName, </span><span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>    <span class="dt">int</span> id, </span><span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>    <span class="bu">ArrayList</span>&lt;<span class="bu">String</span>&gt; duplicateConditionFields, </span><span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>    <span class="bu">ArrayList</span>&lt;<span class="bu">String</span>&gt; foreignKeys,</span><span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>    <span class="bu">Map</span>&lt;<span class="bu">String</span>, <span class="bu">String</span>&gt; newValues</span><span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>) {</span><span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>    <span class="bu">Class</span>&lt;?&gt; dataEntityClass = ...; <span class="co">// 查找对应的Entity层类</span></span><span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>    <span class="bu">Class</span>&lt;?&gt; dataDaoClass = ...; <span class="co">// 查找对应的Dao层类</span></span><span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>    <span class="bu">Method</span> updateByIdMethod = dataDaoClass.<span class="fu">getMethod</span>(<span class="st">&quot;saveAndFlush&quot;</span>); <span class="co">// 查找保存数据的方法</span></span><span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>    <span class="bu">Method</span> findAllMethod = dataDaoClass.<span class="fu">getMethod</span>(<span class="st">&quot;findAll&quot;</span>); </span><span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>    <span class="bu">Field</span> selfField = ...; <span class="co">// 找到自身类中对应的field</span></span><span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a></span><span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a>    <span class="bu">Object</span> targetData = dataEntityClass.<span class="fu">getConstructor</span>().<span class="fu">newInstance</span>(); <span class="co">//获取要更新数据</span></span><span id="cb10-15"><a href="#cb10-15" aria-hidden="true"></a></span><span id="cb10-16"><a href="#cb10-16" aria-hidden="true"></a>    <span class="bu">Boolean</span> isForeignKeyExist = <span class="kw">true</span>;</span><span id="cb10-17"><a href="#cb10-17" aria-hidden="true"></a></span><span id="cb10-18"><a href="#cb10-18" aria-hidden="true"></a>    <span class="co">// 如果满足重复条件或外键不存在则直接返回，这里可以进一步优化</span></span><span id="cb10-19"><a href="#cb10-19" aria-hidden="true"></a>    <span class="kw">for</span>(foreignKey : foreignKeys) {</span><span id="cb10-20"><a href="#cb10-20" aria-hidden="true"></a>        <span class="bu">Class</span>&lt;?&gt; foreignKeyDaoClass = <span class="bu">Class</span>.<span class="fu">forName</span>(targetData.<span class="fu">getDeclaredField</span>(foreignKey).<span class="fu">getType</span>().<span class="fu">getName</span>() + ...); <span class="co">//找到外键对应Dao层类</span></span><span id="cb10-21"><a href="#cb10-21" aria-hidden="true"></a>        <span class="bu">Method</span> findByIdMethod = foreignKeyDaoClass.<span class="fu">getMethod</span>(<span class="st">&quot;findById&quot;</span>); </span><span id="cb10-22"><a href="#cb10-22" aria-hidden="true"></a>        <span class="bu">Field</span> selfField = ...; <span class="co">// 找到自身类中对应的field</span></span><span id="cb10-23"><a href="#cb10-23" aria-hidden="true"></a>        Optional&lt;?&gt; getIdRes = (Optional&lt;?&gt;) findByIdMethod.<span class="fu">invoke</span>(selfField.<span class="fu">get</span>(<span class="kw">this</span>), <span class="bu">Integer</span>.<span class="fu">parseInt</span>(newValues.<span class="fu">get</span>(foreignKey).<span class="fu">getId</span>()));</span><span id="cb10-24"><a href="#cb10-24" aria-hidden="true"></a>        isForeignKeyExist &amp;= !getIdRes.<span class="fu">isEmpty</span>();</span><span id="cb10-25"><a href="#cb10-25" aria-hidden="true"></a>    }</span><span id="cb10-26"><a href="#cb10-26" aria-hidden="true"></a></span><span id="cb10-27"><a href="#cb10-27" aria-hidden="true"></a>    <span class="bu">List</span>&lt;?&gt; getAllRes = (<span class="bu">List</span>&lt;?&gt;) findAllMethod.<span class="fu">invoke</span>(selfField.<span class="fu">get</span>(<span class="kw">this</span>));</span><span id="cb10-28"><a href="#cb10-28" aria-hidden="true"></a></span><span id="cb10-29"><a href="#cb10-29" aria-hidden="true"></a>    <span class="kw">if</span> (<span class="bu">Object</span>.<span class="fu">equals</span>(getAllRes.<span class="fu">findAll</span>().<span class="fu">stream</span>().<span class="fu">filter</span>(data -&gt; {</span><span id="cb10-30"><a href="#cb10-30" aria-hidden="true"></a>        <span class="bu">Boolean</span> isExist = <span class="kw">true</span>;</span><span id="cb10-31"><a href="#cb10-31" aria-hidden="true"></a>        <span class="kw">for</span> (duplicateConditionField : duplicateConditionFields) {</span><span id="cb10-32"><a href="#cb10-32" aria-hidden="true"></a>            isExist &amp;= <span class="bu">Object</span>.<span class="fu">equals</span>(</span><span id="cb10-33"><a href="#cb10-33" aria-hidden="true"></a>                data.<span class="fu">getDeclaredField</span>(duplicateConditionField).<span class="fu">get</span>(data), </span><span id="cb10-34"><a href="#cb10-34" aria-hidden="true"></a>                targetData.<span class="fu">getDeclaredField</span>(duplicateConditionField).<span class="fu">get</span>(targetData)</span><span id="cb10-35"><a href="#cb10-35" aria-hidden="true"></a>            );</span><span id="cb10-36"><a href="#cb10-36" aria-hidden="true"></a>        }</span><span id="cb10-37"><a href="#cb10-37" aria-hidden="true"></a>        <span class="kw">return</span> isExist;</span><span id="cb10-38"><a href="#cb10-38" aria-hidden="true"></a>    }).<span class="fu">collect</span>(Collectors.<span class="fu">toList</span>()).<span class="fu">size</span>(), <span class="dv">0</span>) || !isForeignKeyExist) {</span><span id="cb10-39"><a href="#cb10-39" aria-hidden="true"></a>        <span class="kw">return</span>;</span><span id="cb10-40"><a href="#cb10-40" aria-hidden="true"></a>    }</span><span id="cb10-41"><a href="#cb10-41" aria-hidden="true"></a></span><span id="cb10-42"><a href="#cb10-42" aria-hidden="true"></a>    <span class="co">// 不满足重复条件且外键都存在时，进行数据更新</span></span><span id="cb10-43"><a href="#cb10-43" aria-hidden="true"></a>    <span class="kw">for</span> (field : targetData.<span class="fu">getDeclaredFields</span>()) {</span><span id="cb10-44"><a href="#cb10-44" aria-hidden="true"></a>        field.<span class="fu">set</span>(targetData, newValues.<span class="fu">get</span>(field.<span class="fu">getName</span>()).<span class="fu">toTargetType</span>());</span><span id="cb10-45"><a href="#cb10-45" aria-hidden="true"></a>    }</span><span id="cb10-46"><a href="#cb10-46" aria-hidden="true"></a></span><span id="cb10-47"><a href="#cb10-47" aria-hidden="true"></a>    updateByIdMethod.<span class="fu">invoke</span>(selfField.<span class="fu">get</span>(<span class="kw">this</span>), targetData);</span><span id="cb10-48"><a href="#cb10-48" aria-hidden="true"></a></span><span id="cb10-49"><a href="#cb10-49" aria-hidden="true"></a>    <span class="kw">return</span> ...; <span class="co">// 返回值</span></span><span id="cb10-50"><a href="#cb10-50" aria-hidden="true"></a>}</span></code></pre></div><p>考虑到增改功能逻辑也比较类似，因而增加功能的伪代码不再再次列出。</p><p>借此，大量类似的代码也可以被大幅省略，从而大幅减少工作量，同时也减少了冗余代码。</p><p>当然，这里也可以考虑使用拼接<code>SQL</code>的方法。不过考虑到后端开发上应该尽可能不写或少写原生的<code>SQL</code>，因而这一种写法更符合规范些。</p><p>通过利用上述的写法，项目中的代码可以精简许多，由此也可以使得所需要的测试代码大幅减少，从而使得项目整体的工作量大量降低。事实上，正是由于当前项目中有大量逻辑比较类似的代码，导致为满足覆盖率所需的测试代码非常庞大，从而难以完成自动化测试代码的编写。</p><p>除此之外，一些类内的方法也可以作出一些更改。考虑到方法链的写法更加符合直觉，且也在一定程度上能提升开发效率并使代码更加简洁（尽管在一定程度上破坏了<code>.</code>运算符的原有语义，且也不是很符合 <a href="CQRS">CQRS</a>），因而我个人更倾向于尽可能使用方法链的写法。</p><h3 id="前端">前端</h3><p>我个人而言也作为开发人员参与到了前端组的开发中。事实上最大的优化点在于接口调用的时机。当前，前端组在页面渲染时会请求一次后端接口，获取全部数据并渲染到页面上。之后，在进行关键词查找、数据插入、数据删除时各自会调用一次接口。至此为止都是比较合理的，当数据量庞大时前端不应该负责数据的查找工作，利用在服务器侧进行过优化的查询接口比较合理。然而，前端在进行数据编辑时，则是采用下面的流程：</p><pre class="mermaid"><code>flowchart TD    A[页面选中数据] --&gt; B[获取数据id]    B --&gt; C[根据id再次调用后端接口获取全部数据]    C --&gt; D[根据后端返回渲染页面]    D --&gt; E[用户输入完成后再次调取后端更新数据接口]</code></pre><p>由于在包含全部数据的页面进行初期渲染时每条数据的全部内容前端都已经获取到，因而选中数据进入编辑页面时完全可以直接利用前端已经拿到的数据进行渲染，不需要再次调用后端端口。且不谈在网络延迟较高的情况下，上面的做法会使得用户体验较差，在服务器有大量请求的情况下，前端冗余的调用会加重服务器的负担，从而影响性能。</p><p>另一方面我也注意到，前端由于没有将方法应用到了页面渲染的各个阶段，从而导致了某些请求会被重复多次执行，这也是影响性能的一大问题。当然，最好的解决方法应是前后端都做一下防抖处理。</p><h2 id="一些其他">一些其他</h2><p>开发上的问题大体如上，基本上都是后续项目中值得进行进一步更改的地方。除此以外，整个项目的生命周期中最最值得被后续继承的地方在于严格的PR-Code Review制度与文档的维护。其中前者保证了代码的质量与规范，后者则提高了有效沟通的效率。这两者才是在开发过程中降低工作量与各类成本的最关键因素。</p><h2 id="名词释义">名词释义</h2><h3 id="rad">RAD</h3><p>快速应用开发模型（Rapid Application Development），又称V模型。似乎是为了改进瀑布式模型而在上世纪70至80年代提出的。这一模型大体上遵循下图的几个阶段：</p><figure><img src="https://pikapikapikaori.github.io/pikapikapi-blog/archive/ITtech/_media/SoftwareInsights-20230428/RAD-model.webp" alt="" /><figcaption>picture</figcaption></figure><h3 id="微服务">微服务</h3><p>SOA（面向服务架构）的一种变体，提倡将单一应用程序划分为松耦合的服务组，每个服务可独立部署。其概念最早于2005年提出。</p><figure><img src="https://pikapikapikaori.github.io/pikapikapi-blog/archive/ITtech/_media/SoftwareInsights-20230428/microservice.png" alt="" /><figcaption>picture</figcaption></figure><h3 id="微前端">微前端</h3><p>2016年被正式提出，是微服务这一概念被扩展到前端的一种应用形式，便于新老项目的共存与过渡，以及项目独立开发等。</p><figure><img src="https://pikapikapikaori.github.io/pikapikapi-blog/archive/ITtech/_media/SoftwareInsights-20230428/mircro-frontend.png" alt="" /><figcaption>picture</figcaption></figure><h3 id="java反射机制"><code>Java</code>反射机制</h3><p><code>Java</code>先编译后运行，对象类型在编译期确定。在程序运行时类被动态加载，当类没被用到时没有被加载到JVM，因而利用反射，可以在运行时获得类的各种内容。通过利用反射，可以动态地创建对象，更加灵活，但是会消耗系统资源。</p><h3 id="cqrs">CQRS</h3><p>Command Query Responsibility Segregation，即命令查询职责分离模式，要求一个方法更改对象的状态或返回一个结果，但是不能同时包含这两个行为。从某种角度来说算是继承了从前将系统交互视为CRUD的思想。相较之下，方法链（Method Chaining）语法中由于对象被引用一次即可被多次调用，从某种意义上违反了这一原则。</p><p>更具体的，符合CQRS与<code>.</code>运算符原有语义（<code>调用者.操作名</code>）的写法形如下面的形式：</p><div class="sourceCode" id="cb12"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>Person p = <span class="kw">new</span> <span class="fu">Person</span>();</span><span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>p.<span class="fu">getWater</span>();</span><span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>p.<span class="fu">drinkWater</span>();</span><span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>p.<span class="fu">getThirsty</span>();</span></code></pre></div><p>而方法链则形如下面的形式：</p><div class="sourceCode" id="cb13"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">new</span> <span class="fu">Person</span>().<span class="fu">getWater</span>().<span class="fu">drinkWater</span>().<span class="fu">getThirsty</span>();</span></code></pre></div><p>这种写法更符合直觉，同时可以节省临时变量、简化代码。</p><h2 id="参考资料">参考资料</h2><ol type="1"><li>When I should use one to one relationship? (2012, September 7). Stack Overflow. https://stackoverflow.com/questions/12318870/when-i-should-use-one-to-one-relationship</li><li>search using regex in JPA. (2020, June 15). Stack Overflow. https://stackoverflow.com/questions/62379559/search-using-regex-in-jpa</li><li>Using Java Reflection. (n.d.). Using Java Reflection. https://www.oracle.com/technical-resources/articles/java/javareflection.html</li><li>Rapid application development - Wikipedia. (2014, July 2). Rapid Application Development - Wikipedia. https://en.wikipedia.org/wiki/Rapid_application_development</li><li>Jackson, C. (2019, June 19). Micro Frontends. martinfowler.com. https://martinfowler.com/articles/micro-frontends.html</li><li>M. (n.d.). CQRS pattern - Azure Architecture Center. CQRS Pattern - Azure Architecture Center | Microsoft Learn. https://learn.microsoft.com/en-us/azure/architecture/patterns/cqrs</li><li>Method chaining - why is it a good practice, or not? (2009, July 9). Stack Overflow. https://stackoverflow.com/questions/1103985/method-chaining-why-is-it-a-good-practice-or-not</li></ol>]]></content>
    <pubDate>Sat, 13 Apr 2024 14:51:20 +0800</pubDate>
  </entry>
   
  <entry>
    <title><![CDATA[个人博客搭建心得（壹）：以CSS 3为代表的一些前端开发感悟]]></title>
    <link>https://pikapikapikaori.github.io/pikapikapi-blog/#/archive/ITtech/BlogBuildingNotesOne-20230508</link>
    <guid isPermaLink="false">https://pikapikapikaori.github.io/pikapikapi-blog/#/archive/ITtech/BlogBuildingNotesOne-20230508</guid>
    <content type="html"><![CDATA[<h1 id="个人博客搭建心得壹以css-3为代表的一些前端开发感悟">个人博客搭建心得（壹）：以CSS 3为代表的一些前端开发感悟</h1><blockquote><p>本文首发于个人博客<br />发表日期：2023.05.08<br />最后编辑于：{docsify-last-updated}</p></blockquote><h2 id="前期考虑">前期考虑</h2><p>最近搭个人博客，最终选择了利用Docsify这个框架，主要原因有这么几点；</p><h3 id="经济成本">经济成本</h3><p>尽管家里有两台有公网的服务器，但考虑到备案的时间长短、以及一些其他的隐性成本，因而使用家里服务器甚至于国内可购买的服务器都不是一个很好的选择。相应的，如果在国外购买服务器一是支付方式不便捷，二来需要较高的成本。</p><p>相较之下由于我的个人博客不会有超大量的文章以及评论等，因而可以直接部署的静态网页成了一个相当好的选择。以GitHub Pages和Vercel为代表的一众平台都给个人用户提供了较多的资源用于前端搭建，使得搭建博客的成本可以大大降低。同时，这些平台都支持https协议，并且生成的域名也不是很难看。即使实在不喜欢也可以很容易的自己购买域名进行配置，非常简便。</p><h3 id="开发成本">开发成本</h3><p>由于我更希望我的博客注重于转写文章本身而非锻炼开发能力之类的，因而使用现成的博客框架是第一考虑。</p><p>看了很久博客框架发现Docsify算是一个比较轻量级的框架。首先Docsify本身的快速搭建是极方便的，宣扬的十分钟还是半小时搭一个简单网页确实不是吹的。更重要的是，动态渲染这一特性不像Hexo为代表的其他框架一样需要编译甚至部署后才能查看，相反本地起个server就能即使看到效果，这对博客定制化开发与博客内容的撰写都是相当方便的一大特性。由动态渲染这一特性延伸出来的便是二次开发的高度灵活性。借用Docsify自身提供的几个钩子，甚至不用也行，可以直接以UMD方式挂在其他前端轮子，或者自己写好css和js后直接挂载进来，而无需其他的一系列操作。相较之下Hexo、Vuepress为代表的其他框架可能开发上就相对死板一些，不是很符合我个人喜好。</p><h3 id="docsify总结">Docsify总结</h3><p>总体来看Docsify现成轮子会相对少一点，不过这些东西可以自己随便写写玩反倒更灵活自由，不过动态渲染这一点使得撰写与开发都相当便捷这是我很喜欢的一点。当然SEO可能会相对差一点，不过这一点一来可以考虑利用v4提供的SSR来解决，相反即使不解决我都部署在GitHub Pages上了我显然是不需要也不想要做这个的。</p><p>总之再用上这么个框架后，为了满足自己喜好加点自己想要的花里胡哨的界面啊功能啊之类的东西，最近写了不少原生的html 5 + css 3 + js代码，确实是有不少感悟。</p><h2 id="css">CSS</h2><!-- panels:start --><!-- div:left-panel --><p>感悟最深的大概就是css的使用了。说实话一直以来我其实在服务端做的东西比较多，前端基本上就是用用组件库应付应付课设，也不会特别关注美观度啊动画啊之类的东西。写博客为了想要点好看的东西不得不好好看看css写法，发现原来css还能玩的这么花里胡哨。比如在我博客的<a href="/writings/BriefComments">随笔下的短评部分</a>，我想要以年为单位记录短评，每个年份类似一个details标签的行为，但是默认的details标签样式实在太丑了，我也不想为了这么个简单的小功能写一大段js挂在到<code>index.html</code>，看了看stackoverflow上发现可以用伪元素来写：</p><p>当然这里用了<code>@media</code>来做响应式，这也是以前很少考虑的一点。一方面基本上不会怎么去做不同分辨率屏幕的适配，一方面就算做基本上也就是用个ElementUI的布局就算完事了。现在想想感觉其实是有点太依赖组件库了，不是一个很好的事。最近想试试用Swift写Web后端的时候第一反应也是看看Vapor怎么用，感觉确实是有点太思维定势了：后端用框架、前端用框架加组件库。工程上说挺合理的，节约成本。不过自己开发的时候一来是高度定制化的需求很难满足，二来确实会少很多乐趣。</p><!-- div:right-panel --><iframe width="100%" height="300px" src="//jsfiddle.net/pikapikapi/b9Lu37v6/embedded/html,css,result/?fontColor=c6a2eb&amp;accentColor=c6a2eb" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><!-- div:left-panel --><p>说回css，这个伪元素确实是个很好用的东西。同样是这个界面，我想在标题之间加个分割线，希望这个分割线是中间有个小星星，然后左右有两条短线；而在短评内部最下方日期上希望有个动态的吃豆人分割线。同样是利用了伪元素就可以很简单的实现：</p><p>这里<code>animation</code>和<code>@keyframe</code>也是css 3新特性，可以很方便的去做动画效果。</p><!-- div:right-panel --><iframe width="100%" height="300px" src="//jsfiddle.net/pikapikapi/pyb42tus/10/embedded/html,css,result/?fontColor=c6a2eb&amp;accentColor=c6a2eb" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><!-- div:left-panel --><p>当然也可以利用<code>transform</code>这个新特性来做动画效果。这个博客上右侧的小组件显示隐藏逻辑就是这么做的：</p><!-- div:right-panel --><iframe width="100%" height="300px" src="//jsfiddle.net/pikapikapi/ft3kares/28/embedded/?fontColor=c6a2eb&amp;accentColor=c6a2eb" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><!-- panels:end --><h2 id="js">js</h2><!-- panels:start --><!-- div:left-panel --><p>另外js上碰到的最大的麻烦是想做个查看大图的功能，看了看stackoverflow上比较高的做法是做一个宽<code>100vw</code>高<code>100vh</code>的整体span，点击图片把span的<code>display</code>设成<code>block</code>，再点span设成<code>none</code>，不过那个版本太粗糙还有很多问题，比如我要放按钮的话子元素点击也会触发父元素的。今天重构了一下大概变成现在的样子：</p><p>思路还是用span遮盖，同时设置<code>z-index</code>防其他事件的影响，在span里面放div来包裹组件，同时span的点击事件先去根据事件的<code>target.id</code>来判断触发者，从而来确保子元素点击事件不会总是触发父元素的点击事件。</p><p>js逻辑里拿元素根据类名做filter的步骤感觉可以用<code>querySelectorAll</code>来简化一下。</p><p>另外也用<code>backdrop-filter</code>和<code>-webkit-backdrop-filter</code>做了个毛玻璃的背景效果，更好看些。</p><!-- div:right-panel --><iframe width="100%" height="300" src="//jsfiddle.net/pikapikapi/fkt849L2/15/embedded/?fontColor=c6a2eb&amp;accentColor=c6a2eb" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><!-- panels:end --><h2 id="参考资料">参考资料</h2><ol type="1"><li>How to position marker to come after. (2019, June 25). Stack Overflow. https://stackoverflow.com/questions/56758098/how-to-position-detail-marker-to-come-after-summary</li><li>How do I make an image full screen on click? (2021, June 3). Stack Overflow. https://stackoverflow.com/questions/67815853/how-do-i-make-an-image-full-screen-on-click</li></ol>]]></content>
    <pubDate>Sat, 13 Apr 2024 14:51:20 +0800</pubDate>
  </entry>
   
  <entry>
    <title><![CDATA[IT技術に関する記事]]></title>
    <link>https://pikapikapikaori.github.io/pikapikapi-blog/#/jp/archive/ITtech</link>
    <guid isPermaLink="false">https://pikapikapikaori.github.io/pikapikapi-blog/#/jp/archive/ITtech</guid>
    <content type="html"><![CDATA[<h1 id="it技術に関する記事">IT技術に関する記事</h1><p>このカテゴリには主にコンピュータテクノロジに関する記事と、私が実装したツールやプロジェクトがあります。さらに、過去の論文の読書メモもいくつかあります。主な方向はゲーム理論とメカニズム設計です。</p><p>詳細は<a href="/jp/archive/ITtech/">こちら</a>でご覧ください。</p>]]></content>
    <pubDate>Sat, 13 Apr 2024 14:30:34 +0800</pubDate>
  </entry>
   
  <entry>
    <title><![CDATA[IT Tech Related]]></title>
    <link>https://pikapikapikaori.github.io/pikapikapi-blog/#/en-us/archive/ITtech</link>
    <guid isPermaLink="false">https://pikapikapikaori.github.io/pikapikapi-blog/#/en-us/archive/ITtech</guid>
    <content type="html"><![CDATA[<h1 id="it-tech-related">IT Tech Related</h1><p>This category mainly contains articles related to computer science technology, as well as some useful tools or projects I realized. Besides, there are also some of my notes about essays, the main directions of which being game theory and mechanism design.</p><p>You can check <a href="/en-us/archive/ITtech/">here</a> for details。</p>]]></content>
    <pubDate>Sat, 13 Apr 2024 14:30:34 +0800</pubDate>
  </entry>
   
  <entry>
    <title><![CDATA[实用工具整理]]></title>
    <link>https://pikapikapikaori.github.io/pikapikapi-blog/#/archive/ITtech/UsefulToolsOrApps</link>
    <guid isPermaLink="false">https://pikapikapikaori.github.io/pikapikapi-blog/#/archive/ITtech/UsefulToolsOrApps</guid>
    <content type="html"><![CDATA[<h1 id="实用工具整理">实用工具整理</h1><blockquote><p>本篇主要记录一些我认为比较实用的工具、框架、平台等</p></blockquote><h2 id="项目">项目</h2><h3 id="项目小工具">项目小工具</h3><table><thead><tr class="header"><th style="text-align: center;">名称（链接）</th><th style="text-align: center;">说明</th><th style="text-align: center;">备注</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><a href="https://shields.io/">Shields.io</a></td><td style="text-align: center;">badge（徽章）制作</td><td style="text-align: center;"><a href="https://github.com/badges/shields">GitHub</a></td></tr></tbody></table><h3 id="部署">部署</h3><table><thead><tr class="header"><th style="text-align: center;">名称（链接）</th><th style="text-align: center;">说明</th><th style="text-align: center;">备注</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><a href="https://vercel.com/">Vercel</a></td><td style="text-align: center;">可以直接部署前端静态界面，<br>也支持以FaaS方式部署一些语言的后端服务器</td><td style="text-align: center;"><a href="https://github.com/vercel/vercel">GitHub</a></td></tr></tbody></table><h2 id="前端">前端</h2><h3 id="前端用小工具">前端用小工具</h3><table><thead><tr class="header"><th style="text-align: center;">名称（链接）</th><th style="text-align: center;">说明</th><th style="text-align: center;">备注</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><a href="https://iconoir.com">Iconoir</a></td><td style="text-align: center;">SVG格式Icon生成器</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><a href="https://tablericons.com">Tabler</a></td><td style="text-align: center;">SVG格式Icon生成器</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><a href="https://phosphoricons.com">Phosphor</a></td><td style="text-align: center;">SVG格式Icon生成器</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><a href="https://jam-icons.com">JAM</a></td><td style="text-align: center;">SVG格式Icon生成器</td><td style="text-align: center;"><a href="https://github.com/michaelampr/jam">GitHub</a></td></tr><tr class="odd"><td style="text-align: center;"><a href="https://www.visiwig.com">VISIWIG</a></td><td style="text-align: center;">SVG格式Icon、花纹、材质等生成器</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><a href="https://simpleicons.org/">Simple Icons</a></td><td style="text-align: center;">SVG格式Icon下载器</td><td style="text-align: center;"><a href="https://github.com/simple-icons/simple-icons">GitHub</a></td></tr></tbody></table><h3 id="组件库-框架-包">组件库 &amp; 框架 &amp; 包</h3><table><thead><tr class="header"><th style="text-align: center;">名称（链接）</th><th style="text-align: center;">说明</th><th style="text-align: center;">备注</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><a href="https://www.naiveui.com/">Naive UI</a></td><td style="text-align: center;">Vue组件库</td><td style="text-align: center;"><a href="https://github.com/tusen-ai/naive-ui">GitHub</a></td></tr></tbody></table>]]></content>
    <pubDate>Sat, 13 Apr 2024 14:30:34 +0800</pubDate>
  </entry>
   
  <entry>
    <title><![CDATA[论文阅读 2023.11]]></title>
    <link>https://pikapikapikaori.github.io/pikapikapi-blog/#/archive/ITtech/PaperReading-202311-20231114</link>
    <guid isPermaLink="false">https://pikapikapikaori.github.io/pikapikapi-blog/#/archive/ITtech/PaperReading-202311-20231114</guid>
    <content type="html"><![CDATA[<h1 id="论文阅读-2023.11">论文阅读 2023.11</h1><blockquote><p>本文首发于个人博客<br />发表日期：2023.11.24<br />最后编辑于：{docsify-last-updated}</p></blockquote><h2 id="on-existence-of-truthful-fair-cake-cutting-mechanisms">On Existence of Truthful Fair Cake Cutting Mechanisms</h2><blockquote><p>Tao, B. (2022, July 12). On Existence of Truthful Fair Cake Cutting Mechanisms. Proceedings of the 23rd ACM Conference on Economics and Computation. https://doi.org/10.1145/3490486.3538321</p></blockquote><p>在传统的切蛋糕（cake-cutting，换言之某个异质可分的物体）问题中，往往以比例性或无嫉妒来衡量分配方法的公平与否。然而，参与人可能会谎报自己的估值函数来获得更多的分配。本文考虑从博弈论角度入手，如何设计一个机制来解决这个问题。</p><h3 id="问题建模">问题建模</h3><p>考虑一个异质可分的物体（蛋糕），其被建模为区间<span class="math inline">[0, 1]</span>，要被分配给<span class="math inline"><em>n</em></span>个智能体。每个智能体<span class="math inline"><em>i</em></span>有一个值密度函数$f_i: [0, 1] <em>{} <span class="math inline"><em>来</em><em>描</em><em>述</em><em>他</em><em>对</em><em>蛋</em><em>糕</em><em>的</em><em>偏</em><em>好</em>。<em>如</em><em>果</em></span>[0, 1]<span class="math inline"><em>可</em><em>以</em><em>划</em><em>分</em><em>为</em><em>有</em><em>限</em><em>多</em><em>个</em><em>区</em><em>间</em>，<em>则</em><em>价</em><em>值</em><em>密</em><em>度</em><em>函</em><em>数</em></span>f_i<span class="math inline"><em>是</em><em>分</em><em>段</em><em>常</em><em>数</em>，<em>并</em><em>且</em></span>f_i<span class="math inline"><em>在</em><em>每</em><em>个</em><em>区</em><em>间</em><em>上</em><em>都</em><em>是</em><em>常</em><em>数</em>。<em>文</em><em>章</em><em>考</em><em>虑</em><em>代</em><em>理</em><em>的</em><em>价</em><em>值</em><em>密</em><em>度</em><em>函</em><em>数</em><em>是</em><em>分</em><em>段</em><em>常</em><em>数</em>。<em>如</em><em>果</em></span>f_i(x)&gt;0x<span class="math inline">，<em>则</em><em>智</em><em>能</em><em>体</em></span>i<span class="math inline"><em>是</em><em>饥</em><em>饿</em>（<em>h</em><em>u</em><em>n</em><em>g</em><em>r</em><em>y</em>）<em>的</em>。<em>给</em><em>定</em><em>一</em><em>个</em><em>子</em><em>集</em></span>X<span class="math inline">，</span>i<span class="math inline"><em>在</em></span>X<span class="math inline"><em>上</em><em>的</em><em>效</em><em>用</em><em>为</em></span>v_i(X)=</em>{X}f_i(x)dx$。</p><p>分配<span class="math inline">(<em>A</em><sub>1</sub>, ⋯, <em>A</em><sub><em>n</em></sub>)</span>是<span class="math inline">[0, 1]</span>互不相交子集的集合，其中<span class="math inline"><em>A</em><sub><em>i</em></sub></span>是 分配给智能体<span class="math inline"><em>i</em></span>的子集。下面有对分配几个定义：</p><ul><li><strong>完整</strong>：如果<span class="math inline">$\bigcup^n_{i=1}A_i=[0,1]$</span>，则分配是完整的。</li><li><strong>成比例</strong>：如果每个代理收到整个蛋糕的平均份额，则分配是成比例的。即<span class="math inline">$\forall i:\quad v_i(A_i)\geq\frac{1}{n}v_i([0,1])$</span>。</li><li><strong><span class="math inline"><em>α</em></span>-成比例</strong>：<span class="math inline">$\forall i:\quad v_i(A_i)\geq\frac{\alpha}{n}v_i([0,1])$</span>。</li><li><strong>无嫉妒</strong>：如果每个代理人根据他自己的估值获得的部分的价值略高于任何其他代理人收到的任何部分的价值。即<span class="math inline">∀<em>i</em>, <em>j</em>  <em>v</em><sub><em>i</em></sub>(<em>A</em><sub><em>i</em></sub>) ≥ <em>v</em><sub><em>i</em></sub>(<em>A</em><sub><em>j</em></sub>)</span>。</li></ul><p>无嫉妒分配总是成比例的。如果只有两个参与人，如果分配是完整的，那么分配是成比例的当且仅当它是无嫉妒的。</p><p>机制是函数<span class="math inline">ℳ</span>，它将<span class="math inline"><em>n</em></span>个值密度函数<span class="math inline"><em>F</em> = (<em>f</em><sub>1</sub>, ⋯, <em>f</em><sub><em>n</em></sub>)</span>映射到分配<span class="math inline">(<em>A</em><sub>1</sub>, ⋯, <em>A</em><sub><em>n</em></sub>)</span>。给定<span class="math inline">ℳ(<em>F</em>) = (<em>A</em><sub>1</sub>, ⋯, <em>A</em><sub><em>n</em></sub>)</span>，记<span class="math inline"><em>M</em><sub><em>i</em></sub>(<em>F</em>) = <em>A</em><sub><em>i</em></sub></span>。如果分配始终给出成比例的分配或无嫉妒分配，则机制是完整的。文章仅考虑确定性机制。</p><p>如果每个智能体的主导策略是报告他的真实价值函数密度，则机制<span class="math inline">ℳ</span>是真实的，即<span class="math inline"><em>v</em><sub><em>i</em></sub>(ℳ<sub><em>i</em></sub>(<em>f</em><sub>1</sub>, ⋯, <em>f</em><sub><em>n</em></sub>)) ≥ <em>v</em><sub><em>i</em></sub>(ℳ<sub><em>i</em></sub>(<em>f</em><sub>1</sub>, ⋯, <em>f</em><sub><em>i</em> − 1</sub>, <em>f</em>′<sub><em>i</em></sub>, <em>f</em><sub><em>i</em> + 1</sub>, ⋯, <em>f</em><sub><em>n</em></sub>)), ∀<em>i</em> ∈ [<em>n</em>], ∀(<em>f</em><sub>1</sub>, ⋯, <em>f</em><sub><em>n</em></sub>), ∀<em>f</em>′<sub><em>i</em></sub></span>。</p><h3 id="机制的存在性">机制的存在性</h3><p>文章首先证明，即使以下所有条件成立，也不存在真实的比例机制：</p><ul><li>有两名代理人</li><li>每个智能体的价值密度函数是分段常数</li><li>每个智能体都处于饥饿状态：每个<span class="math inline"><em>f</em><sub><em>i</em></sub></span>都满足<span class="math inline"><em>f</em><sub><em>i</em></sub>(<em>x</em>) &gt; 0  ∀<em>x</em> ∈ [0, 1]</span></li><li>机制不需要是完整的：机制可能会丢弃蛋糕的一部分。</li></ul><p>更具体的，文章利用反证法证明了该结论。假设两个智能体存在一个真实的比例机制<span class="math inline">ℳ</span>，那么构造多个切蛋糕实例，分析<span class="math inline">ℳ</span>在这些实例上的输出，并证明无法保证所有这些实例的真实性和比例性。</p><p>文章构造了六个实例，对于前五个实例，文章表明<span class="math inline">ℳ</span>的输出是唯一的。基于前五个实例的输出，文章表明任何<span class="math inline">ℳ</span>对构造的第六个实例的分配输出将违反比例性或真实性。</p><figure><img src="https://pikapikapikaori.github.io/pikapikapi-blog/archive/ITtech/_media/PaperReading-202311-20231114/picture-1.png" alt="" /><figcaption>picture</figcaption></figure><ol type="1"><li><span class="math inline">∀<em>x</em> ∈ [0, 1]</span>。显然这里<span class="math inline">$|\mathcal{M}_1(F^{(1)})|=|\mathcal{M}_2(F^{(1)})|=\frac{1}{2}$</span>。记<span class="math inline"><em>X</em><sub>1</sub> = ℳ<sub>1</sub>(<em>F</em><sup>(1)</sup>), <em>X</em><sub>2</sub> = ℳ<sub>2</sub>(<em>F</em><sup>(1)</sup>)</span>。形象的，可以考虑<span class="math inline"><em>X</em><sub>1</sub> = [0, 0.5], <em>X</em><sub>2</sub> = (0.5, 1]</span><ul><li><span class="math inline"><em>F</em><sup>(1)</sup> = (<em>f</em><sub>1</sub><sup>(1)</sup>, <em>f</em><sub>2</sub><sup>(1)</sup>)</span></li><li><span class="math inline"><em>f</em><sub>1</sub><sup>(1)</sup>(<em>x</em>) = 1</span></li><li><span class="math inline"><em>f</em><sub>2</sub><sup>(1)</sup>(<em>x</em>) = 1</span></li></ul></li><li><span class="math inline">∀<em>x</em> ∈ [0, 1]</span>。<ul><li><span class="math inline"><em>F</em><sup>(2)</sup> = (<em>f</em><sub>1</sub><sup>(2)</sup>, <em>f</em><sub>2</sub><sup>(2)</sup>)</span></li><li><span class="math inline"><em>f</em><sub>1</sub><sup>(2)</sup>(<em>x</em>) = 1</span></li><li><span class="math inline">$f^{(2)}_2(x)=\begin{cases}\epsilon&amp;x\in X_1\\1&amp;x\in X_2\end{cases}$</span></li></ul></li><li><span class="math inline">∀<em>x</em> ∈ [0, 1]</span>。记<span class="math inline"><em>X</em><sub>11</sub> = ℳ<sub>1</sub>(<em>F</em><sup>(3)</sup>)⋂<em>X</em><sub>1</sub>, <em>X</em><sub>12</sub> = ℳ<sub>2</sub>(<em>F</em><sup>(3)</sup>)⋂<em>X</em><sub>1</sub>, <em>X</em><sub>21</sub> = ℳ<sub>1</sub>(<em>F</em><sup>(3)</sup>)⋂<em>X</em><sub>2</sub>, <em>X</em><sub>22</sub> = ℳ<sub>2</sub>(<em>F</em><sup>(3)</sup>)⋂<em>X</em><sub>2</sub></span>。形象地，<span class="math inline"><em>X</em><sub>11</sub> = [0, 0.25], <em>X</em><sub>12</sub> = (0.25, 0.5], <em>X</em><sub>21</sub> = (0.5, 0.75], <em>X</em><sub>22</sub> = (0.75, 1]</span>。<ul><li><span class="math inline"><em>F</em><sup>(3)</sup> = (<em>f</em><sub>1</sub><sup>(3)</sup>, <em>f</em><sub>2</sub><sup>(3)</sup>)</span></li><li><span class="math inline">$f^{(3)}_1(x)=\begin{cases}0.5&amp;x\in X_1\\1&amp;x\in X_2\end{cases}$</span></li><li><span class="math inline">$f^{(3)}_2(x)=\begin{cases}\epsilon&amp;x\in X_1\\1&amp;x\in X_2\end{cases}$</span></li></ul></li><li><span class="math inline">∀<em>x</em> ∈ [0, 1]</span>。<ul><li><span class="math inline"><em>F</em><sup>(4)</sup> = (<em>f</em><sub>1</sub><sup>(4)</sup>, <em>f</em><sub>2</sub><sup>(4)</sup>)</span></li><li><span class="math inline">$f^{(4)}_1(x)=\begin{cases}1&amp;x\in X_{11}\\\epsilon&amp;x\in X_{12}\\2\epsilon&amp;x\in X_{21}\\\epsilon&amp;x\in X_{22}\end{cases}$</span></li><li><span class="math inline">$f^{(4)}_2(x)=\begin{cases}\epsilon&amp;x\in X_1\\1&amp;x\in X_2\end{cases}$</span></li></ul></li><li><span class="math inline">∀<em>x</em> ∈ [0, 1]</span>。<ul><li><span class="math inline"><em>F</em><sup>(5)</sup> = (<em>f</em><sub>1</sub><sup>(5)</sup>, <em>f</em><sub>2</sub><sup>(5)</sup>)</span></li><li><span class="math inline"><em>f</em><sub>1</sub><sup>(5)</sup>(<em>x</em>) = 1</span></li><li><span class="math inline">$f^{(5)}_2(x)=\begin{cases}1-\epsilon&amp;x\in X_{11}\\\epsilon&amp;x\in X_{12}\\1&amp;x\in X_2\end{cases}$</span></li></ul></li><li><span class="math inline">∀<em>x</em> ∈ [0, 1]</span>。<ul><li><span class="math inline"><em>F</em><sup>(6)</sup> = (<em>f</em><sub>1</sub><sup>(6)</sup>, <em>f</em><sub>2</sub><sup>(6)</sup>)</span></li><li><span class="math inline">$f^{(6)}_1(x)=\begin{cases}1&amp;x\in X_{11}\\\epsilon&amp;x\in X_{12}\\2\epsilon&amp;x\in X_{21}\\\epsilon&amp;x\in X_{22}\end{cases}$</span></li><li><span class="math inline">$f^{(6)}_2(x)=\begin{cases}1-\epsilon&amp;x\in X_{11}\\\epsilon&amp;x\in X_{12}\\1&amp;x\in X_2\end{cases}$</span></li></ul></li></ol><p>文章证明 在最后一个实例的情况下，不能找到一个能输出保证真实性与成比例的分配的机制。因此，考虑对真实性或比例性的进行要求上的放宽。文章首先证明，如果不放松真实性，那么近似比例机制（0.974031-近似）是不存在的。</p><h3 id="较弱的真实性保证规避风险的真实性">较弱的真实性保证：规避风险的真实性</h3><p>文章证明，如果机制<span class="math inline">ℳ</span>满足，所以参与人如实报告其价值密度函数的策略形成纳什均衡，则<span class="math inline">ℳ</span>是真实的。</p><p>文章首先定义了规避风险的真实性：</p><p>如果对于具有价值密度函数<span class="math inline"><em>f</em><sub><em>i</em></sub></span>的每个代理人<span class="math inline"><em>i</em></span>以及对于任何<span class="math inline"><em>f</em>′<sub><em>i</em></sub></span>，以下任一条件成立，那么机制<span class="math inline">ℳ</span>是风险规避真实的：</p><ul><li>对任何<span class="math inline"><em>f</em><sub>1</sub>, ⋯, <em>f</em><sub><em>i</em> − 1</sub>, <em>f</em><sub><em>i</em> + 1</sub>, ⋯, <em>f</em><sub><em>n</em></sub></span>，有<span class="math inline"><em>v</em><sub><em>i</em></sub>(ℳ<sub><em>i</em></sub>(<em>f</em><sub>1</sub>, ⋯, <em>f</em><sub><em>i</em> − 1</sub>, <em>f</em><sub><em>i</em></sub>, <em>f</em><sub><em>i</em> + 1</sub>, ⋯, <em>f</em><sub><em>n</em></sub>)) ≥ <em>v</em><sub><em>i</em></sub>(ℳ<sub><em>i</em></sub>(<em>f</em><sub>1</sub>, ⋯, <em>f</em><sub><em>i</em> − 1</sub>, <em>f</em>′<sub><em>i</em></sub>, <em>f</em><sub><em>i</em> + 1</sub>, ⋯, <em>f</em><sub><em>n</em></sub>))</span></li><li>存在某个<span class="math inline"><em>f</em><sub>1</sub>, ⋯, <em>f</em><sub><em>i</em> − 1</sub>, <em>f</em><sub><em>i</em> + 1</sub>, ⋯, <em>f</em><sub><em>n</em></sub></span>，使得<span class="math inline"><em>v</em><sub><em>i</em></sub>(ℳ<sub><em>i</em></sub>(<em>f</em><sub>1</sub>, ⋯, <em>f</em><sub><em>i</em> − 1</sub>, <em>f</em>′<sub><em>i</em></sub>, <em>f</em><sub><em>i</em> + 1</sub>, ⋯, <em>f</em><sub><em>n</em></sub>)) &lt; <em>v</em><sub><em>i</em></sub>(ℳ<sub><em>i</em></sub>(<em>f</em><sub>1</sub>, ⋯, <em>f</em><sub><em>i</em> − 1</sub>, <em>f</em><sub><em>i</em></sub>, <em>f</em><sub><em>i</em> + 1</sub>, ⋯, <em>f</em><sub><em>n</em></sub>))</span></li></ul><p>如果<span class="math inline">ℳ</span>是成比例的，并且对于具有价值密度函数<span class="math inline"><em>f</em><sub><em>i</em></sub></span>的每个代理人<span class="math inline"><em>i</em></span>以及对于任何<span class="math inline"><em>f</em>′<sub><em>i</em></sub></span>，以下任一条件成立，那么机制<span class="math inline">ℳ</span>是比例风险规避真实的：</p><ul><li>对任何<span class="math inline"><em>f</em><sub>1</sub>, ⋯, <em>f</em><sub><em>i</em> − 1</sub>, <em>f</em><sub><em>i</em> + 1</sub>, ⋯, <em>f</em><sub><em>n</em></sub></span>，有<span class="math inline"><em>v</em><sub><em>i</em></sub>(ℳ<sub><em>i</em></sub>(<em>f</em><sub>1</sub>, ⋯, <em>f</em><sub><em>i</em> − 1</sub>, <em>f</em><sub><em>i</em></sub>, <em>f</em><sub><em>i</em> + 1</sub>, ⋯, <em>f</em><sub><em>n</em></sub>)) ≥ <em>v</em><sub><em>i</em></sub>(ℳ<sub><em>i</em></sub>(<em>f</em><sub>1</sub>, ⋯, <em>f</em><sub><em>i</em> − 1</sub>, <em>f</em>′<sub><em>i</em></sub>, <em>f</em><sub><em>i</em> + 1</sub>, ⋯, <em>f</em><sub><em>n</em></sub>))</span></li><li>存在某个<span class="math inline"><em>f</em><sub>1</sub>, ⋯, <em>f</em><sub><em>i</em> − 1</sub>, <em>f</em><sub><em>i</em> + 1</sub>, ⋯, <em>f</em><sub><em>n</em></sub></span>，使得<span class="math inline">$v_i(\mathcal{M}_i(f_1,\cdots,f_{i-1},f'_i,f_{i+1},\cdots,f_n))&lt;\frac{1}{n}v_i([0,1])$</span></li></ul><h3 id="风险规避真实的无嫉妒机制">风险规避真实的无嫉妒机制</h3><p>首先考虑下面的算法：</p><figure><img src="https://pikapikapikaori.github.io/pikapikapi-blog/archive/ITtech/_media/PaperReading-202311-20231114/picture-2.png" alt="" /><figcaption>picture</figcaption></figure><p>该算法可以为具有分段常数值密度函数的参与人输出无嫉妒分配。该算法首先从所有参与人收集所有不连续点，从而将蛋糕划分为多个区间，其中每个参与人的价值密度函数在每个区间上都是均匀的。然后，该算法将每个区间统一分配给所有参与人。该算法的输出分配<span class="math inline">(<em>A</em><sub>1</sub>, ⋯, <em>A</em><sub><em>n</em></sub>)</span>满足<span class="math inline">$v_i(A_j)=\frac{1}{n}v_i([0,1])$</span>（这个分配的属性称为完美），这显然是无嫉妒。 然而，为了使算法具有确定性，我们需要指定参与人从左到右的顺序，以了解每个间隔的分配方式。当然，此算法不是风险规避真实的。</p><p>原因是，参与人可以“删除”连续点来合并两个区间<span class="math inline">[<em>x</em><sub><em>j</em></sub>, <em>x</em><sub><em>j</em> + 1</sub>)</span>和<span class="math inline">[<em>x</em><sub><em>j</em> + 1</sub>, <em>x</em><sub><em>j</em> + 2</sub>)</span>。 如果他的价值在<span class="math inline">[<em>x</em><sub><em>j</em></sub>, <em>x</em><sub><em>j</em> + 1</sub>)</span>（或<span class="math inline">[<em>x</em><sub><em>j</em> + 1</sub>, <em>x</em><sub><em>j</em> + 2</sub>)</span>）上更高，并且他知道该机制将在最左边分配一块<span class="math inline">[<em>x</em><sub><em>j</em></sub>, <em>x</em><sub><em>j</em> + 2</sub>)</span>。因此，每个区间上确定性的从左到右的顺序会损害真实性。</p><p>基于此，文章提出了下面的机制，其能够输出一个比例风险规避真实的、无嫉妒的分配。该机制与上面的机制相同，只是每个区间<span class="math inline">[<em>x</em><sub><em>j</em></sub>, <em>x</em><sub><em>j</em> + 1</sub>)</span>上从左到右的顺序取决于索引<span class="math inline"><em>j</em></span>。直观上，如果一个智能体尝试合并两个区间，他不知道他在<span class="math inline">[<em>x</em><sub><em>j</em></sub>, <em>x</em><sub><em>j</em> + 1</sub>)</span>的<span class="math inline">$\frac{1}{n}$</span>的部分在哪里，因为他不知道其他智能体的值密度函数。这使得他最终可能会收到价值较低的部分。</p><figure><img src="https://pikapikapikaori.github.io/pikapikapi-blog/archive/ITtech/_media/PaperReading-202311-20231114/picture-3.png" alt="" /><figcaption>picture</figcaption></figure><h3 id="具有关联块的比例风险规避真实的机制">具有关联块的比例风险规避真实的机制</h3><p>机制2可能导致许多参与人收到零碎的区间，而在某些情况下参与人可能更享受到一块整区间。</p><p>考虑两个经典算法，其能给出具有连续区间的分配：</p><ol type="1"><li>动刀算法（Moving-knife）：令<span class="math inline">$a_i=\frac{1}{n}v_i([0,1])$</span>为代理<span class="math inline"><em>i</em></span>的比例值。动刀算法为每个代理<span class="math inline"><em>i</em></span>标记一个点<span class="math inline"><em>x</em><sub><em>i</em></sub></span>，使得<span class="math inline">[0, <em>x</em><sub><em>i</em></sub>)</span>对代理<span class="math inline"><em>i</em></span>恰好是值<span class="math inline"><em>a</em><sub><em>i</em></sub></span>。然后，算法找到<span class="math inline"><em>x</em><sub>1</sub>, ⋯, <em>x</em><sub><em>n</em></sub></span>中的最小值<span class="math inline"><em>x</em><sub><em>i</em><sup>*</sup></sub></span>，并将<span class="math inline">[0, <em>x</em><sub><em>i</em><sup>*</sup></sub>)</span>分配给代理人<span class="math inline"><em>i</em><sup>*</sup></span>。 接下来，对于蛋糕的剩余部分<span class="math inline">[<em>x</em><sub><em>i</em><sup>*</sup></sub>, 1]</span>，算法为<span class="math inline"><em>n</em> − 1</span>个剩余代理的每个标记一个点<span class="math inline"><em>x</em>′<sub><em>i</em></sub></span>，使得<span class="math inline">[<em>x</em><sub><em>i</em><sup>*</sup></sub>, <em>x</em>′<sub><em>i</em></sub>)</span>对于代理<span class="math inline"><em>i</em></span>来说正好值<span class="math inline"><em>a</em><sub><em>i</em></sub></span>。然后算法找到<span class="math inline"><em>n</em> − 1</span>个<span class="math inline"><em>x</em>′<sub><em>i</em></sub></span>中最小值<span class="math inline"><em>x</em><sub><em>i</em><sup><em>t</em></sup></sub></span>，并将<span class="math inline">[<em>x</em><sub><em>i</em><sup>*</sup></sub>, <em>x</em><sub><em>i</em><sup><em>t</em></sup></sub>)</span>分配给代理<span class="math inline"><em>i</em><sup><em>t</em></sup></span>。不断重复直到第<span class="math inline"><em>n</em> − 1</span>个智能体被分配了一个间隔，然后最后一个智能体获得了蛋糕的剩余部分。很容易验证每个前<span class="math inline"><em>n</em> − 1</span>个智能体收到的间隔恰好等于他的比例值，而最后一个智能体可能收到超过他比例值。</li><li>Even-Paz算法：是一个基于divide-and-conquer的算法。对每个参与人<span class="math inline"><em>i</em></span>，算法找到某个点<span class="math inline"><em>x</em><sub><em>i</em></sub></span>使得<span class="math inline">$v_i([0,x_i])=\lfloor\frac{n}{2}\rfloor v_i([0,1])$</span>。随后其找点<span class="math inline"><em>x</em><sub>1</sub>, ⋯, <em>x</em><sub><em>n</em></sub></span>的中值<span class="math inline"><em>x</em><sup>*</sup></span>。令<span class="math inline"><em>L</em></span>是全部参与人<span class="math inline"><em>i</em></span>使得<span class="math inline"><em>x</em><sub><em>i</em></sub> &lt; <em>x</em><sup>*</sup></span>的集合，<span class="math inline"><em>R</em></span>是全部参与人<span class="math inline"><em>i</em></span>使得<span class="math inline"><em>x</em><sub><em>i</em></sub> ≥ <em>x</em><sup>*</sup></span>的集合。由于<span class="math inline"><em>L</em></span>中每个参与人<span class="math inline"><em>i</em></span>都相信<span class="math inline">$v_i([0,x^*])\geq\lfloor\frac{n}{2}\rfloor v_i([0,1])$</span>，且<span class="math inline"><em>L</em></span>中有<span class="math inline">$\lfloor\frac{n}{2}\rfloor$</span>歌参与人，因而<span class="math inline">[0, <em>x</em><sup>*</sup>]</span>存在某个分配，使得<span class="math inline"><em>L</em></span>中每个参与人<span class="math inline"><em>i</em></span>都收到至少<span class="math inline">$\frac{1}{n}v_i([0,1])$</span>。递归地解决这两部分即可。</li></ol><p>当然，两个算法也都不是比例风险回避真实的。</p><p>因此，文章最后提出了下面的机制。特别是，如果需要全部分配，那么对于饥饿的参与人来说，它是比例风险规避真实的。</p><figure><img src="https://pikapikapikaori.github.io/pikapikapi-blog/archive/ITtech/_media/PaperReading-202311-20231114/picture-4.png" alt="" /><figcaption>picture</figcaption></figure><p>为了使得机制对非饥饿的参与人也是比例风险回避真实的，可以通过不全部分配来实现：只需要将第7行的分配改为将<span class="math inline">[<em>x</em><sub><em>j</em> − 1</sub><sup>(<em>i</em><sub><em>j</em></sub>)</sup>, <em>c</em><sub><em>j</em></sub>)</span>分配给代理人<span class="math inline"><em>i</em><sub><em>j</em></sub></span>。</p><h2 id="参考资料">参考资料</h2><ol type="1"><li>Tao, B. (2022, July 12). On Existence of Truthful Fair Cake Cutting Mechanisms. Proceedings of the 23rd ACM Conference on Economics and Computation. https://doi.org/10.1145/3490486.3538321</li></ol>]]></content>
    <pubDate>Sat, 13 Apr 2024 14:30:34 +0800</pubDate>
  </entry>
   
  <entry>
    <title><![CDATA[论文阅读 2023.09]]></title>
    <link>https://pikapikapikaori.github.io/pikapikapi-blog/#/archive/ITtech/PaperReading-202310-20231016</link>
    <guid isPermaLink="false">https://pikapikapikaori.github.io/pikapikapi-blog/#/archive/ITtech/PaperReading-202310-20231016</guid>
    <content type="html"><![CDATA[<h1 id="论文阅读-2023.09">论文阅读 2023.09</h1><blockquote><p>本文首发于个人博客<br />发表日期：2023.10.31<br />最后编辑于：{docsify-last-updated}</p></blockquote><h2 id="randomized-fifo-mechanisms">Randomized FIFO Mechanisms</h2><blockquote><p>Castro, F., Ma, H., Nazerzadeh, H., &amp; Yan, C. (2022, July 12). Randomized FIFO Mechanisms. Proceedings of the 23rd ACM Conference on Economics and Computation. https://doi.org/10.1145/3490486.3538353</p></blockquote><p>考虑一个打车平台，平台需要为每个乘客匹配一个司机，文章则着重研究如果实现较好的匹配。在传统的先进先出（FIFO）匹配中，平台维护一个司机列表（等待订单时间最久的司机排在头部），并优先匹配列表头部的司机。然而，在这种调度下司机很容易获得订单，这导致在列表头部的司机会倾向于拒绝低价值的订单而等待高价值的。从而，中等或低价值的订单很难被接受，这降低了平台的收入与出行的吞吐量较低。</p><p>为了解决这一问题，近年平台开始对司机进行限制：例如，平台正在向预先估算距离与收入的方向发展，并可能会在司机未接订单时隐藏目的地。然而，经验丰富的司机很容易绕过这些限制。另一方面，强制司机接受每个订单可能会使得每个司机获得的利益相差过大，从而降低司机的参与度，甚至可能导致司机离开平台。也有研究后进先出（LIFO）的可应用性，然而这会导致不公平：司机可以随时离线以参加到队列末尾，且在队列头部的将很难获得订单。</p><p>目前已有研究提出了时空价格机制（spatio-temporal pricing mechanism），其能保证社会福利最优与激励一致，然而这在实践中难以实现。一方面，对较短的行程提高定价并不合理，同时平台也无法让司机的支出定于某个预先设置好的单价，这也导致较长行程的收入难以降低。</p><p>由于某些行程总是能获得更多利益，文章研究在不调整行程价格的前提下，如何进行行程订单的分配。文章考虑行程具有一个起点，同时乘客和司机具有固定到达率。乘客要求前往多个目的地，而司机的收入也各不相同。当每个乘客到达时，或者乘客的行程请求被拒绝后，平台会将乘客的行程提供给队列中的司机。乘客愿意为一次匹配等待一段时间，但他们会在被司机拒绝一定次数后会取消订单。司机排队等候订单这一行为对于司机和平台来说成本都很高。司机旨在优化他们的总回报，即行程收入减去他们产生的等待成本。</p><p>文章考虑，在任何时间点，司机都知道供应、需求、队列长度以及他们在队列中的位置。 当提出行程请求时，司机会预先获得行程目的地和收入，以决定是否接受。此外，司机不会因为他们采取的任何行动而受到惩罚，并且可以拒绝任意数量的行程调度而不会失去他们在队列中的位置，在任何时间点重新加入队列的尾部，以及决定在抵达出发点时不加入队列，或在任何时间离开队列，从而可以在没有乘客的情况下重新返回出发点。</p><p>文章首先提出直接先进先出机制，该机制将低收入的行程直接提供给队列中较靠后的司机。文章证明接受所有调度在司机之间形成了子博弈完美均衡，并且均衡结果实现了第一最佳行程吞吐量和第二最佳净收入（即通过任何灵活和透明的机制可实现的最高稳态净收入）。然而，直接FIFO机制在实践中被认为是不公平的。以芝加哥中途机场为例。距离队列头部足够近的司机将不再接收任何返回芝加哥市中心的行程。</p><p>为了在不使用不公平调度规则的情况下实现最佳吞吐量和收入，文章引入了一系列随机FIFO机制。 随机 FIFO 机制由队列中的一组桶指定（例如，前10个位置、第10到20个位置等）。每个行程请求首先统一随机地提供给第一个容器中的司机。每次拒绝后，该机制都会将行程提供给下一个桶中的随机司机。通过以这种随机方式逐渐将订单发送到队列中，随机FIFO机制利用等待时间适当地调整激励措施，实现第一最佳吞吐量和第二最佳净收入；跳过队列其余部分的选项会激励队列中更靠后的司机接受收入较低的旅行；将每次调度随机分配给一小群司机，会增加每个司机等待下一次调度的时间，从而允许该机制优先考虑靠近队列头部的司机前往每个目的地，而不会刺激过度挑选。</p><h3 id="机制模型">机制模型</h3><p>考虑一个连续时间的模型，模型中有一个统一的起点，乘客的行程被分派给在队列中等待的司机。<span class="math inline">ℒ = {1, 2, ⋯, <em>l</em>}</span>表明了离散行程类型（比如目的地不同）的集合<span class="math inline"><em>l</em> ∈ ℤ<sub> &gt; 0</sub></span>。乘客的需求与司机的供应都是非原子的，并且不随时间推移改变。对每个位置<span class="math inline"><em>i</em> ∈ ℒ</span>，<span class="math inline"><em>μ</em><sub><em>i</em></sub> &gt; 0</span>表示请求到达位置<span class="math inline"><em>i</em></span>的乘客的到达率（换言之，单位时间到达的乘客数量）。在乘客到达后，其需求需要被分派给司机。所有的乘客都有一个耐心等级<span class="math inline"><em>P</em> ∈ ℤ<sub> &gt; 0</sub></span>，其表明乘客的需求在被司机接受前乘客愿意等待的时间，但乘客也可能会在第<span class="math inline"><em>P</em><sup>th</sup></span>次被司机拒绝后取消行程并离开。司机可以承载任何乘客到目的地，乘客本身没有对司机的偏好。</p><p>接着用<span class="math inline"><em>λ</em> &gt; 0</span>表示司机的到达率。在司机到达后，司机需要决定是否要加入队列。到达每个位置<span class="math inline"><em>i</em> ∈ ℒ</span>的净收入是<span class="math inline"><em>w</em><sub><em>i</em></sub></span>，其表明司机在完成到位置<span class="math inline"><em>i</em></span>的行程时可以获得收益<span class="math inline"><em>w</em><sub><em>i</em></sub></span>，而不加入队列或不携带行程订单就离开队列的司机的收入为0。司机在队列中等待的每个单位时间，都会产生机会成本<span class="math inline"><em>c</em> &gt; 0</span>，平台产生的机会成本则为<span class="math inline"><em>c</em><sub><em>p</em></sub> ∈ [0, <em>c</em>]</span>。司机具有战略性，他们想要最优化行程的收入与等待的机会成本的差值，且对于乘客或目的地没有偏好。</p><p>调度机制本身的时间表如下：在每个乘客到达时，机制会将乘客的行程需求分发给队列中的司机，如果司机接受了这次分派的行程，那么会离开队列以接乘客。否则，行程会被重新分派，直到有司机接受行程订单、乘客取消订单或机制决定不分派订单。</p><p>文章考虑如下的设置：机制有对需求、供应、机会成本以及到不同行程的净收入的完整信息，假设全部司机也都共享相同的信息。文章希望设计一种透明灵活的机制，即在任何时刻司机都知道队列的总长度与自己在队列中的位置。当司机被分派行程订单时，能够预知行程的目的地与净收入，以决定是否要接受这个订单。此外，司机不会因为自己的行动而被惩罚，并乐意选择是否：在拒绝订单的同时保留自己在队列中的位置；在任何时刻重新加入队列的末尾；不加入队列或在没有乘客的情况下离开队列。</p><p>平台的吞吐量事单位时间内队列中司机完成的订单数量。平台的净收入是司机单位时间内完成的订单的净收入和，减去平台在司机等待过程中产生的机会成本。当司机不理性并接受全部被分派的订单时，此时可实现的最高吞吐量所产生的净收入被视为第一最佳收入。</p><p>简单起见，假设行程按顺序排列<span class="math inline"><em>w</em><sub>1</sub> &gt; <em>w</em><sub>2</sub> &gt; ⋯ &gt; <em>w</em><sub><em>l</em></sub> ≥ 0</span>。在需求和供应稳定且无穷小时，平台也不需要非零的司机队列。稳定状态下，一个想要获得更多净收入的平台不应让司机留在队列中，而应在司机到达时按净收入降序分派订单，直到司机队列为空或乘客行程订单被分派完。将被（部分）完成的行程中收入最低的记为<span class="math inline">$i^*=\max\{i]in\mathcal{L}|\lambda&gt;\sum^{i-1}_{j=1}u_j\}$</span>（相当于在尽可能满足更多的订单的情况下将前面的订单尽可能分派给司机）。</p><p>稳定状态下的第一最佳收入发生在队列中没有司机的情况。司机到达时就被以净收入倒序分派订单。剩下的司机则被建议离开队列（可以去别的起点接乘客）。第一最佳的吞吐量为<span class="math inline"><em>T</em><sub><em>F</em><em>B</em></sub> = min {<em>λ</em>, ∑<sub><em>i</em> ∈ ℒ</sub><em>μ</em><sub><em>i</em></sub>}</span>，第一最佳收入则为<span class="math inline">$R_{FB}=\sum^{i^*-1}_{i=1}w_i\mu_i + w_i\cdot\min\{\lambda-\sum^{i^*-1}_{i=1}\mu_i,\mu_{i^*}\}$</span>。</p><h3 id="严格fifo分派">严格FIFO分派</h3><p>研究表明如果司机能够灵活的选择订单，这会刺激过度的挑选。在严格FIFO分派下，考虑到目的地1的乘客订单，这一订单会被队列头部的司机接受（注意目的地已经按净收入降序排序）。另一方面，在头部（无穷小）的司机只愿意接受到位置1的订单，因为他在队列头部，能够接受所有订单，也不需要等待到目的地1的订单。</p><p>类似的，一个司机愿意接受到目的地2的订单仅当到位置1的订单的额外等待时间超过<span class="math inline"><em>w</em><sub>1</sub> − <em>w</em><sub>2</sub></span>。令<span class="math inline">𝒯<sub>1, 2</sub></span>表明司机相比于立刻接受到位置2的订单，愿意等待到位置1的最大额外时间，即¥¥<span class="math inline">𝒯<sub>1, 2</sub> = (<em>w</em><sub>1</sub> − <em>w</em><sub>2</sub>)/<em>c</em></span>。根据利特尔法则有第一个愿意接受到位置2订单的司机排在位置<span class="math inline">$n_2\overset{\Delta}{=}\mu_1\mathcal{T}_{1,2}$</span>而对于这个位置的司机，他的持续受益（净收益减去时间成本）是<span class="math inline"><em>w</em><sub>2</sub></span>。类似的，相比于前往位置<span class="math inline"><em>i</em> + 1</span>，愿意等待去位置<span class="math inline"><em>i</em></span>的司机需要额外的<span class="math inline">𝒯<sub><em>i</em>, <em>i</em> + 1</sub></span>单位的等待时间。</p><p>因而如果乘客有无限耐心且不会订单，非形式化地，在<span class="math inline"><em>n</em><sub><em>i</em></sub></span>位置的司机总能得到<span class="math inline"><em>w</em><sub><em>i</em></sub></span>的持续预期受益。在均衡时，只有当司机的位置<span class="math inline"><em>q</em> ≥ <em>n</em><sub><em>i</em></sub></span>时才应该接受分派的订单：</p><p><br /><span class="math display">$$\begin{align*}    n_1 &amp;= 0\\    n_i &amp;\overset{\Delta}{=} \sum^{i-1}_{j=1}(\frac{w_j-w_{j+1}}{c}\sum^j_{k=1}\mu_k),\forall i\geq2\end{align*}$$</span><br /></p><p>文章计算出这种情况下的均衡，等价于如下的子博弈完美均衡：</p><ul><li>当且仅当司机位置在<span class="math inline"><em>q</em> ≥ <em>n</em><sub><em>i</em></sub></span>时接受到每个位置<span class="math inline"><em>i</em> ∈ ℒ</span>的订单</li><li>当且仅当队列长度弱低于<span class="math inline">$\overline{Q}$</span>时加入队列，并在加入后永远不离开队列或重新加入队列末尾。这里<span class="math inline">$\overline{Q}\overset{\Delta}{=}n_l+\frac{w_l}{c}\sum^l_{i=1}\mu_i=\sum_{i\in\mathcal{L}}w_i\mu_i/c$</span>。</li></ul><p>然而，若乘客耐心有限，那么乘客的订单将不会到达愿意接受这一订单的司机。</p><figure><img src="https://pikapikapikaori.github.io/pikapikapi-blog/archive/ITtech/_media/PaperReading-202310-20231016/picture-1.png" alt="" /><figcaption>picture</figcaption></figure><h3 id="直接fifo机制">直接FIFO机制</h3><p>文章接着介绍了一种不公平的机制，在这一机制中，在队列末尾的司机会被优先分派订单。</p><p>更形式化的，对长度为<span class="math inline"><em>Q</em> &gt; 0</span>的队列，令<span class="math inline"><em>q</em> ∈ [0, <em>Q</em>]</span>为队列中的一个特定位置，其中<span class="math inline"><em>q</em> = 0</span>代表在队列头部，也就是等待了最久时间的司机。令<span class="math inline"><em>h</em></span>表示特定乘客行程订单的分发历史，也就是提供过这一行程的司机当时在队列中的位置。用<span class="math inline"><em>ϕ</em></span>表示不分发该行程的决定。</p><p>调度机制如下：给定长度<span class="math inline"><em>Q</em></span>的队列，行程的历史<span class="math inline"><em>h</em></span>以及行程的目的地，该机制在<span class="math inline">[0, <em>Q</em>] ∪ {<em>ϕ</em>}</span>上确定一个概率分布。当乘客到达，或乘客的订单被某个司机拒绝后，机制要么将行程订单重新分派给队列中处于某个位置<span class="math inline"><em>q</em></span>的司机，要么拒绝该行程。</p><p>这一机制根据队列长度这一状态与行程的分派历史来决定分派，而不依赖于其他因素。文章同样关注司机基于队列长度与司机位置所做出的决策，并将这一策略记为三元组<span class="math inline"><em>σ</em> = (<em>α</em>, <em>β</em>, <em>γ</em>)</span>：</p><ol type="1"><li><span class="math inline"><em>α</em>(<em>q</em>, <em>Q</em>, <em>i</em>) ∈ [0, 1]</span>是位于位置<span class="math inline"><em>q</em></span>的司机在被分派到位置<span class="math inline"><em>i</em></span>的行程订单时接受的概率</li><li><span class="math inline"><em>β</em>(<em>q</em>, <em>Q</em>) ∈ [0, 1]</span>是位于位置<span class="math inline"><em>q</em></span>的司机重新加入队列末尾的概率</li><li><span class="math inline"><em>γ</em>(<em>q</em>, <em>Q</em>) ∈ [0, 1]</span>是位于位置<span class="math inline"><em>q</em></span>的司机离开队列并不携带乘客的概率</li></ol><p>令<span class="math inline"><em>U</em>(<em>q</em>, <em>Q</em>, <em>σ</em>, <em>σ</em>′)</span>表示当队列长度<span class="math inline"><em>Q</em></span>，该司机接受策略<span class="math inline"><em>σ</em></span>而其他司机接受策略<span class="math inline"><em>σ</em>′</span>时（包括未来加入队列的司机），位于位置<span class="math inline"><em>q</em></span>的司机持续受益的随机变量。这包括了司机未来可能获得的净收益，减去从此时开始在队列中等待产生的机会成本的差。将<span class="math inline">$\pi(q,Q,\sigma,\sigma')\overset{\Delta}{=}\mathbb{E}[U(q,Q,\sigma,\sigma')]$</span>表示司机从位置<span class="math inline"><em>q</em></span>开始的期望收益。文章接着进行了以下定义：</p><ul><li><strong>子博弈完美均衡（SPE, subgame perfect equilibrium）</strong>：策略<span class="math inline"><em>σ</em><sup>*</sup></span>在司机间形成子博弈完美均衡，如果对任何经济体与任何可行的策略<span class="math inline"><em>σ</em></span>，有<span class="math inline"><em>π</em>(<em>q</em>, <em>Q</em>, <em>σ</em><sup>*</sup>, <em>σ</em><sup>*</sup>) ≥ <em>π</em>(<em>q</em>, <em>Q</em>, <em>σ</em>, <em>σ</em><sup>*</sup>), ∀<em>Q</em> ≥ 0, ∀<em>q</em> ∈ [0, <em>Q</em>]</span></li><li><strong>个体理性（IR）</strong>：机制在SPE下是IR的，如果策略<span class="math inline"><em>σ</em><sup>*</sup></span>在司机间形成子博弈完美均衡时，对任何经济体，<span class="math inline"><em>π</em>(<em>q</em>, <em>Q</em>, <em>σ</em><sup>*</sup>, <em>σ</em><sup>*</sup>) ≥ 0, ∀<em>Q</em> ≥ 0, ∀<em>q</em> ∈ [0, <em>Q</em>]</span></li><li>无嫉妒（Envy-freeness）：一个机制在SPE下是无嫉妒的，如果策略<span class="math inline"><em>σ</em><sup>*</sup></span>在司机间形成子博弈完美均衡时，对任何经济体，<span class="math inline"><em>π</em>(<em>q</em><sub>1</sub>, <em>Q</em>, <em>σ</em><sup>*</sup>, <em>σ</em><sup>*</sup>) ≥ <em>π</em>(<em>q</em><sub>2</sub>, <em>Q</em>, <em>σ</em><sup>*</sup>, <em>σ</em><sup>*</sup>), ∀<em>Q</em> ≥ 0, ∀<em>q</em><sub>1</sub>, <em>q</em><sub>2</sub> ∈ [0, <em>Q</em>] s.t. <em>q</em><sub>1</sub> ≤ <em>q</em><sub>2</sub></span></li></ul><p>给定机制<span class="math inline">ℳ</span>与在其达到SPE的策略<span class="math inline"><em>σ</em><sup>*</sup></span>，令<span class="math inline"><em>Q</em><sup>*</sup></span>表示在该策略下稳定状态时队列的长度，换言之此时单位时间加入队列的司机数量与离开队列的司机数量相等。用<span class="math inline"><em>z</em><sub><em>i</em></sub>(<em>σ</em><sup>*</sup>)</span>表示当所有司机都采用策略<span class="math inline"><em>σ</em><sup>*</sup></span>时，在稳定状态下完成的目的地为<span class="math inline"><em>i</em></span>的行程订单占比，因而有吞吐量：<span class="math inline">$T_{\mathcal{M}}(\sigma^*)\overset{\Delta}{=}\sum_{i\in\mathcal{L}}z_i(\sigma^*)\mu_i$</span>。平台净收益为<span class="math inline">$R_{\mathcal{M}}(\sigma^*)\overset{\Delta}{=}\sum_{i\in\mathcal{L}}z_i(\sigma^*)\mu_i w_i-Q^* c_p$</span>。当<span class="math inline"><em>c</em><sub><em>p</em></sub> = <em>c</em></span>时，平台的净收益就等于全部司机的净收益。</p><p>机制预期能达到第一最佳吞吐量，以及第二最佳收入，即当机制透明灵活，能给司机提供全部信息，并不会惩罚司机时，在稳定均衡状态下的最大净收益。</p><p><strong>直接FIFO机制</strong>：到每个目的地<span class="math inline"><em>i</em> ∈ ℒ</span>的行程被以FIFO形式分发给队列中从<span class="math inline"><em>n</em><sub><em>i</em></sub></span>位置开始的司机，并要求此时<span class="math inline"><em>Q</em> ≥ <em>n</em><sub><em>i</em></sub></span>，否则不分派该行程。若乘客有无限的耐心，则按照严格FIFO机制调度。</p><p>文章证明在这种机制下全部司机接受直接FIFO机制分发的行程订单，并当且仅当队列最大为<span class="math inline">$\overline{Q}\overset{\Delta}{=}n_l+\frac{w_l}{c}\sum_{i\in\mathcal{L}}\mu_i$</span>时才加入队列，采用这样的策略能够达到SPE。同时，该均衡也是IR和无嫉妒的。另一方面，当司机数量大于所需数量时，尽管机制无法实现第一最佳收入，但能够实现第二最佳收入与第一最佳吞吐量。</p><figure><img src="https://pikapikapikaori.github.io/pikapikapi-blog/archive/ITtech/_media/PaperReading-202310-20231016/picture-2.png" alt="" /><figcaption>picture</figcaption></figure><p>然而，在直接FIFO机制下靠近头部的司机可能会比后面的司机以更慢的速度接收到某些目的地的行程订单，因此不太公平。</p><h3 id="随机fifo机制">随机FIFO机制</h3><p>文章最后提出了随机FIFO机制，该机制相对公平，并能实现最佳的均衡情况下的吞吐量与净收益。文章首先定义了在所有订单都被均匀随机地分派给全部司机情况下的均衡状态：</p><p><strong>稳定状态下的纳什均衡</strong>：在某个机制下，策略<span class="math inline"><em>σ</em><sup>*</sup></span>在司机间形成了稳定状态下的纳什均衡，当存在队列长度<span class="math inline"><em>Q</em><sup>*</sup> ≥ 0</span>使得：</p><ol type="1"><li>对任何可行的策略<span class="math inline"><em>σ</em></span>和队列中任意位置<span class="math inline"><em>q</em> ∈ [0, <em>Q</em><sup>*</sup>]</span>，有<span class="math inline"><em>π</em>(<em>q</em>, <em>Q</em><sup>*</sup>, <em>σ</em><sup>*</sup>, <em>σ</em><sup>*</sup>) ≥ <em>π</em>(<em>q</em>, <em>Q</em><sup>*</sup>, <em>σ</em>, <em>σ</em><sup>*</sup>)</span></li><li>当所有司机都采用策略<span class="math inline"><em>σ</em><sup>*</sup></span>，且稳定的状态表明队列长度为<span class="math inline"><em>Q</em><sup>*</sup></span></li></ol><p>文章表明，在达到稳定状态下的纳什均衡时，最佳的机制实现了第一最佳吞吐量与第二最佳收入。当<span class="math inline"><em>c</em><sub><em>p</em></sub> = 0</span>时，也实现了第一最佳收入。</p><figure><img src="https://pikapikapikaori.github.io/pikapikapi-blog/archive/ITtech/_media/PaperReading-202310-20231016/picture-3.png" alt="" /><figcaption>picture</figcaption></figure><p><strong>随机FIFO机制</strong>：随机FIFO机制被队列<span class="math inline">$([\underline{b}^{(1)},\overline{b}^{(1)}],[\underline{b}^{(2)},\overline{b}^{(2)}],\cdots,[\underline{b}^{(m)},\overline{b}^{(m)}])$</span>中<span class="math inline"><em>m</em> ≥ 1</span>个桶（bin）指定。当行程被第<span class="math inline"><em>k</em></span>次分派时，机制将其均匀随机地分发给第<span class="math inline"><em>k</em></span>个桶<span class="math inline">$[\underline{b}^{(k)},\overline{b}^{(k)}]$</span>中的司机。</p><p>给定任意经济体，令<span class="math inline">(ℒ<sup>(1)</sup>, ℒ<sup>(2)</sup>, ⋯, ℒ<sup>(<em>m</em>)</sup>)</span>为前<span class="math inline"><em>i</em><sup>*</sup></span>个目的地<span class="math inline">{1, 2, ⋯, <em>i</em><sup>*</sup>} ∈ ℒ</span>的有序划分，其中<span class="math inline"><em>m</em> ≤ min {<em>i</em><sup>*</sup>, <em>P</em>}</span>：</p><ol type="1"><li>总体详尽：<span class="math inline">$\cup^m_{k=1}\mathcal{L}^{(k)}=\{1,2,\cdots,i^*\},\forall k\in[1,m],\mathcal{L}^{(k)}\neq\emptyset$</span></li><li>互斥：<span class="math inline">∀<em>k</em><sub>1</sub>, <em>k</em><sub>2</sub> ≤ <em>m</em> s.t. <em>k</em><sub>1</sub> ≠ <em>k</em><sub>2</sub>, ℒ<sup>(<em>k</em><sub>1</sub>)</sup> ∩ ℒ<sup>(<em>k</em><sub>2</sub>)</sup> = ∅</span></li><li>单调：<span class="math inline">∀<em>k</em><sub>1</sub>, <em>k</em><sub>2</sub> ≤ <em>m</em> s.t. <em>k</em><sub>1</sub> ≠ <em>k</em><sub>2</sub>, <em>i</em> &lt; <em>j</em>∀<em>i</em> ∈ ℒ<sup>(<em>k</em><sub>2</sub>)</sup>, <em>j</em> ∈ ℒ<sup>(<em>k</em><sub>2</sub>)</sup></span></li></ol><p>给定一个经济体和前<span class="math inline"><em>i</em><sup>*</sup></span>个目的地<span class="math inline">{1, 2, ⋯, <em>i</em><sup>*</sup>} ∈ ℒ</span>的有序划分<span class="math inline">(ℒ<sup>(1)</sup>, ℒ<sup>(2)</sup>, ⋯, ℒ<sup>(<em>m</em>)</sup>)</span>，按如下方式构造队列<span class="math inline">$([\underline{b}^{(1)},\overline{b}^{(1)}],[\underline{b}^{(2)},\overline{b}^{(2)}],\cdots,[\underline{b}^{(m)},\overline{b}^{(m)}])$</span>中的<span class="math inline"><em>m</em></span>个桶：</p><p><br /><span class="math display">$$\begin{align*}    \underline{b}^{(k)} &amp;\overset{\Delta}{=}\sum_{i\in\cup_{k'&lt;k}\mathcal{L}^{(k')}}(w_i-\min_{i'\in\mathcal{L}^{(k)}}\{w_i'\})\mu_i/c \\    \overline{b}^{(k)} &amp;\overset{\Delta}{=}\sum_{i\in\cup_{k'\leq k}\mathcal{L}^{(k')}}(w_i-\min_{i'\in\mathcal{L}^{(k)}}\{w_i'\})\mu_i/c\end{align*}$$</span><br /></p><p>文章最后具体表明了这一类能实现最佳稳定状态下纳什均衡的随机FIFO机制：</p><p><strong>随机FIFO机制</strong>：对任何经济体和前<span class="math inline"><em>i</em><sup>*</sup></span>个目的地<span class="math inline">{1, 2, ⋯, <em>i</em><sup>*</sup>} ∈ ℒ</span>的有序划分<span class="math inline">(ℒ<sup>(1)</sup>, ℒ<sup>(2)</sup>, ⋯, ℒ<sup>(<em>m</em>)</sup>)</span>，其中<span class="math inline"><em>m</em> ≤ min {<em>i</em><sup>*</sup>, <em>P</em>}</span>，能够满足上述随机分给桶内司机的机制能达到第一最佳吞吐量与第二最佳收入。当<span class="math inline"><em>c</em><sub><em>p</em></sub> = 0</span>时，也实现了第一最佳收入。通过这一种机制，司机的收入的波动性也被大大减小了。</p><h3 id="实验结果">实验结果</h3><figure><img src="https://pikapikapikaori.github.io/pikapikapi-blog/archive/ITtech/_media/PaperReading-202310-20231016/picture-6.png" alt="" /><figcaption>picture</figcaption></figure><figure><img src="https://pikapikapikaori.github.io/pikapikapi-blog/archive/ITtech/_media/PaperReading-202310-20231016/picture-4.png" alt="" /><figcaption>picture</figcaption></figure><p>数据集如上，文章根据实际情况假定了机会成本，乘客到达率等因素。为了估计出行的分布以及按目的地划分的出行净收入，文章利用了芝加哥市公开的乘车共享平台（Uber、Lyft）的出行级别数据。该数据集提供了每次出行的票价（四舍五入到最接近的2.50美元）、每次行程的出发地和目的地，以及每次行程开始和结束的时间戳（四舍五入到最近的15分钟）。芝加哥市内共有801个区，文章将其视为目的地集。</p><p>2018年11月1日至2020年3月11日，从奥黑尔出发的出行总数为453万次。 按目的地区划分的出行次数如图5a，按目的地划分的平均出行费用如图1a。文章假设驾驶员的机会成本为<span class="math inline"><em>c</em> = 1/3</span>，代表在城市中驾驶的平均驾驶员每小时赚取20美元的情况。结合平均票价、平均行程持续时间和机会成本，文章按旅行目的地估算净利润，如图5b。</p><p>文章将乘客的总到达率固定为<span class="math inline">∑<sub><em>i</em> ∈ ℒ</sub><em>μ</em><sub><em>i</em></sub> = 12</span>每分钟。这大致等于工作日傍晚时段完成行程的比率。文章假设平台司机时间的机会成本为每分钟<span class="math inline"><em>c</em><sub><em>p</em></sub> = <em>c</em> = 1/3</span>，这对应于第一最佳和第二最佳净收入之间差距是最大的场景。最后，文章评估的随机FIFO机制对应于将已完成行程集按顺序划分为最多<span class="math inline"><em>P</em></span>个子集，每个子集包含（大约）相同数量的目的地。</p><figure><img src="https://pikapikapikaori.github.io/pikapikapi-blog/archive/ITtech/_media/PaperReading-202310-20231016/picture-5.png" alt="" /><figcaption>picture</figcaption></figure><figure><img src="https://pikapikapikaori.github.io/pikapikapi-blog/archive/ITtech/_media/PaperReading-202310-20231016/picture-7.png" alt="" /><figcaption>picture</figcaption></figure><h2 id="参考文献">参考文献</h2><ol type="1"><li>Castro, F., Ma, H., Nazerzadeh, H., &amp; Yan, C. (2022, July 12). Randomized FIFO Mechanisms. Proceedings of the 23rd ACM Conference on Economics and Computation. https://doi.org/10.1145/3490486.3538353</li></ol>]]></content>
    <pubDate>Sat, 13 Apr 2024 14:30:34 +0800</pubDate>
  </entry>
   
  <entry>
    <title><![CDATA[论文阅读 2023.09]]></title>
    <link>https://pikapikapikaori.github.io/pikapikapi-blog/#/archive/ITtech/PaperReading-202309-20230920</link>
    <guid isPermaLink="false">https://pikapikapikaori.github.io/pikapikapi-blog/#/archive/ITtech/PaperReading-202309-20230920</guid>
    <content type="html"><![CDATA[<h1 id="论文阅读-2023.09">论文阅读 2023.09</h1><blockquote><p>本文首发于个人博客<br />发表日期：2023.10.10<br />最后编辑于：{docsify-last-updated}</p></blockquote><h2 id="the-landscape-of-auto-bidding-auctions-value-versus-utility-maximization">The Landscape of Auto-bidding Auctions: Value versus Utility Maximization</h2><blockquote><p>Balseiro, S., Deng, Y., Mao, J., Mirrokni, V., &amp; Zuo, S. (2021). The Landscape of Auto-Bidding Auctions: Value Versus Utility Maximization. SSRN Electronic Journal. https://doi.org/10.2139/ssrn.3785579</p></blockquote><p>本文关注在支出回报率（RoS）约束下将一个不可分割物品向多个代理人出售的情形下，当买家的目标为私有不被公开时，且买家可能追求最大化价值或最大化期望收入，此时是否能达到第一最佳回报（first best revenue）。</p><p><em>RoS（Return on Spend）：多记为ROAS（Return on Ad Spend），即广告支出回报率，是一种营销指标，用于衡量花在广告上的每一美元所赚取的收入。具体的，其可被计算为广告收入与广告支出的比值。</em></p><figure><img src="https://pikapikapikaori.github.io/pikapikapi-blog/archive/ITtech/_media/PaperReading-202309-20230920/pircture-1.png" alt="" /><figcaption>picture</figcaption></figure><h3 id="广告商-卖家博弈模型">广告商 &amp; 卖家博弈模型</h3><p>考虑将一个不可分割物品卖给<span class="math inline"><em>n</em></span>个买家。买家<span class="math inline"><em>i</em></span>对于物品有估价<span class="math inline">$v_i\in\mathcal{V},\mathcal{V}\subseteq[0,\infin)$</span>，卖家卖出该物品总有固定的支出<span class="math inline"><em>c</em> ≥ 0</span>。该支出可以被视为运输费，或是未从其他渠道进行销售的潜在机会成本。买家<span class="math inline"><em>i</em></span>的估价可由先验分布<span class="math inline"><em>F</em><sub><em>i</em></sub></span>导出，当然每个买家的分布都是独立的。每个买家都有一个需要满足的约束条件，在文章中这一约束被具象化为RoS，其标明了买家收到的价值与实际支出的最小目标比率<span class="math inline">$t_i\in\mathcal{T},\mathcal{T}\subseteq[0,\infin)$</span>。买家<span class="math inline"><em>i</em></span>的目标比率被认为可以由公开的先验分布<span class="math inline"><em>G</em><sub><em>i</em></sub></span>导出，同样这些分布也是独立的。假设<span class="math inline"><em>F</em><sub><em>i</em></sub>(<em>v</em><sub><em>i</em></sub>), <em>G</em><sub><em>i</em></sub>(<em>t</em><sub><em>i</em></sub>)</span>都连续并具有密度<span class="math inline"><em>f</em><sub><em>i</em></sub>(<em>v</em><sub><em>i</em></sub>), <em>g</em><sub><em>i</em></sub>(<em>t</em><sub><em>i</em></sub>)</span>。同样可以用向量标记全部的估值与目标比率：<span class="math inline"><em>v</em>, <em>t</em></span>。</p><p>文章考虑估值与目标RoS比率分别为私有或公开等多种情况下卖家应如何选择拍卖机制。卖家目标是最大化买家付款与固定成本的差值，而买家则可能想要最大化价值，或是最大化回报率。以<span class="math inline"><em>I</em></span>表示支付系数，那么如果买家期望最大化效用那么<span class="math inline"><em>I</em> = 1</span>，如果其希望最大化价值那么<span class="math inline"><em>I</em> = 0</span>，换言之有：<span class="math inline">回报 = 价值 − <em>I</em> ⋅ 支出</span>。</p><p><em>这里是说买家对物品有一个私有的估价，这个估价和买家最终的支出并不要求一定相等（而在传统模型中两者被视为完全相同）。</em></p><p>形式化地，考虑一般情况下买家的估价与目标回报率都私有的情况，机制可由分配规则<span class="math inline"><em>x</em> : (𝒱 × 𝒯)<sup><em>n</em></sup> → [0, 1]<sup><em>n</em></sup></span>与支付规则<span class="math inline"><em>p</em> : (𝒱 × 𝒯)<sup><em>n</em></sup> → ℝ<sup><em>n</em></sup></span>给出，其中<span class="math inline"><em>x</em><sub><em>i</em></sub>(<em>v</em>, <em>t</em>)</span>表示物品被分配给第<span class="math inline"><em>i</em></span>个买家的概率，<span class="math inline"><em>p</em><sub><em>i</em></sub>(<em>v</em>, <em>t</em>)</span>表示其支出。由于仅有一个不可分割的物品，显然有<span class="math inline">$\sum^n_{i=1}x_i(v,t)\leq1$</span>。</p><p>整个拍卖按如下时序发生：</p><ol type="1"><li>每个买家<span class="math inline"><em>i</em></span>从<span class="math inline"><em>G</em><sub><em>i</em></sub></span>导出其目标回报率<span class="math inline"><em>t</em><sub><em>i</em></sub></span>。如果目标回报率私有则买家可以汇报任意<span class="math inline">$\hat{t_i}\in\mathcal{T}$</span>。</li><li>卖家向全部买家公开他们各自的目标回报率。</li><li>买家<span class="math inline"><em>i</em></span>从<span class="math inline"><em>F</em><sub><em>i</em></sub></span>导出估值<span class="math inline"><em>v</em><sub><em>i</em></sub></span>。如果估价私有那么买家可以任意汇报<span class="math inline">$\hat{v_i}\in\mathcal{V}$</span>。当然这里的汇报值应满足他自己的支出回报率。</li><li>卖家向每个买家<span class="math inline"><em>i</em></span>分概率<span class="math inline"><em>x</em><sub><em>i</em></sub>(<em>v̂</em>, <em>t̂</em>)</span>并向他收取支付价格<span class="math inline"><em>p</em><sub><em>i</em></sub>(<em>v̂</em>, <em>t̂</em>)</span>。</li></ol><p>文章意图设计一个使买家能诚实地进行汇报的机制（即激励相容）。更形式化的，假设当买家<span class="math inline"><em>i</em></span>汇报的目标回报率是<span class="math inline">$\hat{t_i}\in \mathcal{T}$</span>，且所有买家都恒定诚实汇报时，假设他在第二阶段（上述后两个阶段）的最佳预期收益是<span class="math inline">$U_i(\hat{t_i};t)$</span>，其中后者<span class="math inline"><em>t</em> ∈ 𝒯<sup><em>n</em></sup></span>是全部买家的目标回报率，那么有：</p><p><br /><span class="math display">$$\begin{align*}U_i(\hat{t_i};t)=&amp;\max_{\alpha:\mathcal{V}\rightarrow\Delta(\mathcal{V})}\mathbb{E}[v_i\cdot x_i((\alpha(v_i),v_{-i}),(\hat{t_i},t_{-i}))-I\cdot p_i((\alpha(v_i),v_{-i}),(\hat{t_i},t_{-i}))] \\&amp;\text{s.t.}\ \mathbb{E}_v[v_i\cdot x_i((\alpha(v_i),v_{-i}),(\hat{t_i},t_{-i}))-t_i\cdot p_i((\alpha(v_i),v_{-i}),(\hat{t_i},t_{-i}))]\geq 0\end{align*}$$</span><br /></p><p>这里<span class="math inline"><em>α</em></span>代表买家随机选择的投标策略，以满使全部买家都能满足自己的回报率约束。</p><p>此时机制是激励相容的，如果其满足：</p><ol type="1"><li>每个买家<span class="math inline"><em>i</em></span>都被预期如实汇报真实的目标回报率：对全部<span class="math inline">$t_i,\hat{t_i}\in\mathcal{T}$</span>，有<span class="math inline">$U_i(t_i;t)\geq U_i(\hat{t_i};t)$</span>。（<span class="math inline"><em>I</em><em>C</em> − <em>t</em></span>）</li><li>每个买家<span class="math inline"><em>i</em></span>都能通过汇报他自己真实的估价（当他如实汇报目标回报率，且其他买家也都如实汇报时）以实现最佳收益：对全部<span class="math inline"><em>t</em> ∈ 𝒯<sup><em>n</em></sup></span>，有<span class="math inline"><em>U</em><sub><em>i</em></sub>(<em>t</em><sub><em>i</em></sub>; <em>t</em>) = 𝔼<sub><em>v</em></sub>[<em>v</em><sub><em>i</em></sub> ⋅ <em>x</em><sub><em>i</em></sub>(<em>v</em>, <em>t</em>) − <em>I</em> ⋅ <em>p</em><sub><em>i</em></sub>(<em>v</em>, <em>t</em>)]</span>。（<span class="math inline"><em>I</em><em>C</em> − <em>v</em></span>）这里这也暗示回报率约束在被诚实汇报时自然地得到满足：对全部买家<span class="math inline"><em>i</em></span>以及目标回报率<span class="math inline"><em>t</em> ∈ 𝒯<sup><em>n</em></sup></span>，<span class="math inline">𝔼<sub><em>v</em></sub>[<em>v</em><sub><em>i</em></sub> ⋅ <em>x</em><sub><em>i</em></sub>(<em>v</em>, <em>t</em>) − <em>t</em><sub><em>i</em></sub> ⋅ <em>p</em><sub><em>i</em></sub>(<em>v</em>, <em>t</em>)] ≥ 0</span>。</li></ol><p>在考虑卖家方机制设计问题时，文章也考虑满足个体理性条件，即需要买家的中期收益也要大于等于零：<span class="math inline"><em>v</em><sub><em>i</em></sub> ⋅ <em>X</em><sub><em>i</em></sub>(<em>v</em><sub><em>i</em></sub>, <em>t</em>) − <em>I</em> ⋅ <em>P</em><sub><em>i</em></sub>(<em>v</em><sub><em>i</em></sub>, <em>t</em>) ≥ 0, ∀<em>i</em>, <em>v</em><sub><em>i</em></sub> ∈ 𝒱, <em>t</em> ∈ 𝒯<sup><em>n</em></sup></span>。这里中期收益被定义为<span class="math inline"><em>X</em><sub><em>i</em></sub>(<em>v</em><sub><em>i</em></sub>, <em>t</em>) = 𝔼<sub><em>v</em><sub> − <em>i</em></sub></sub>[<em>x</em><sub><em>i</em></sub>((<em>v</em><sub><em>i</em></sub>, <em>v</em><sub> − <em>i</em></sub>), <em>t</em>)], <em>P</em><sub><em>i</em></sub>(<em>v</em><sub><em>i</em></sub>, <em>t</em>) = 𝔼<sub><em>v</em><sub> − <em>i</em></sub></sub>[<em>p</em><sub><em>i</em></sub>((<em>v</em><sub><em>i</em></sub>, <em>v</em><sub> − <em>i</em></sub>), <em>t</em>)]</span>。（<span class="math inline"><em>I</em><em>R</em></span>）显然对追求最大化价值的买家IR永远成立，而对于追求最大化效用的买家，IR要求其支付永远不超过价值。</p><p>卖方希望能找到一个满足个体理性（IR）与激励相容的机制，其能够最大化卖方的收益，即<span class="math inline">$OPT=\max_{x,p}\sum^n_{i=1}\mathbb{E}_{v,t}[p_i(v,t)-c\cdot x_i(v,t)] \text{s.t. (IR),(IC-t),(IC-v)}$</span>。文章将机制与第一最佳收入比较，并指出当买家的私人信息都公开时其是可实现的。卖家此时只要满足个体理性与回报率约束即可，换言之有第一最佳收入<span class="math inline">$FB=\max_{x,p}\sum^n_{i=1}\mathbb{E}_{v,t}[p_i(v,t)-c\cdot x_i(v,t)] \text{s.t. (IR),(RoS)}$</span>。</p><p>为了便于计算与证明，考虑目标调整价值（target-adjusted-value）<span class="math inline">$\frac{v_i}{t_i}$</span>。文章证明当该值大于卖家的固定开销时（<span class="math inline">max<sub><em>i</em></sub><em>v</em><sub><em>i</em></sub>/<em>t</em><sub><em>i</em></sub> &gt; <em>c</em></span>），第一最佳机制应当分配给有最高目标调整价值的买家，此时应当向卖家收取该调整价值的费用；否则商品不应当被售出。换言之其类似于有底价<span class="math inline"><em>c</em></span>的一价拍卖，其中买家按目标调整价格排序。直观上看该机制应尽可能大地设定支付价格，以满足回报率约束。倘若将支付价格删去，那么卖家的对象可以被转化为<span class="math inline">$\sum^n_{i=1}(v_i/t_i-c)\cdot x_i(v,t)$</span>，这也正是第一最佳分配。这种机制当然不是激励相容的。</p><p>为了便于记述记<span class="math inline">(<em>x</em>)<sup>+</sup> = max {<em>x</em>, 0}</span>，那么第一最佳收入为<span class="math inline">$FB=\sum^n_{i=1}\mathbb{E}_{v,t}[(\max_i v_i/t_i-c)^+]$</span>，这对于效用最大化与价值最大化两种买家都成立。当<span class="math inline">$p_i(v,t)=(v_i/t_i)\cdot x_i(v,t),x_i(v,t)=1\{i=\argmax_{j:v_j/t_j&gt;c}v_j/t_j\}$</span>时能实现第一最佳收入。</p><h3 id="激励相容的表征">激励相容的表征</h3><p>文章指出IC-v的定义并不容易给出，因其实质上包含了在全部投标策略空间上的优化问题。文章假定对任何目标回报率空间<span class="math inline"><em>t</em></span>每个买家<span class="math inline"><em>i</em></span>和他汇报的目标<span class="math inline">$\hat{t_i}$</span>都存在一个投标策略<span class="math inline"><em>α</em> : 𝒱 → <em>Δ</em>(𝒱)</span>使得<span class="math inline">$\mathbb{E}_{v_i}[v_i\cdot X_i(\alpha(v_i),(\hat{t_i},t_{-i}))-t_i\cdot P_i(\alpha(v_i),(\hat{t_i},t_{-i}))]&gt;0$</span>。（满足IR）。</p><p>文章基于这个假设证明，一个机制是IC-v当切仅当对每个买家<span class="math inline"><em>i</em></span>存在证书函数（certificate function）<span class="math inline"><em>γ</em><sub><em>i</em></sub> : 𝒯<sup><em>n</em></sup> → [0, ∞]</span>使得：</p><ol type="1"><li>对全部<span class="math inline"><em>t</em></span>与全部<span class="math inline"><em>v</em><sub><em>i</em></sub>, <em>v</em><sub><em>i</em></sub>′ ∈ 𝒱</span>有<span class="math inline">(1 + <em>γ</em><sub><em>i</em></sub>(<em>t</em>)) ⋅ <em>v</em><sub><em>i</em></sub> ⋅ <em>X</em><sub><em>i</em></sub>(<em>v</em><sub><em>i</em></sub>, <em>t</em>) − (<em>I</em> + <em>γ</em><sub><em>i</em></sub>(<em>t</em>) ⋅ <em>t</em><sub><em>i</em></sub>) ⋅ <em>P</em><sub><em>i</em></sub>(<em>v</em><sub><em>i</em></sub>, <em>t</em>) ≥ (1 + <em>γ</em><sub><em>i</em></sub>(<em>t</em>)) ⋅ <em>v</em><sub><em>i</em></sub> ⋅ <em>X</em><sub><em>i</em></sub>(<em>v</em><sub><em>i</em></sub>′, <em>t</em>) − (<em>I</em> + <em>γ</em><sub><em>i</em></sub>(<em>t</em>) ⋅ <em>t</em><sub><em>i</em></sub>) ⋅ <em>P</em><sub><em>i</em></sub>(<em>v</em><sub><em>i</em></sub>′, <em>t</em>)</span></li><li><span class="math inline">𝔼<sub><em>v</em><sub><em>i</em></sub></sub>[<em>v</em><sub><em>i</em></sub> ⋅ <em>X</em><sub><em>i</em></sub>(<em>v</em><sub><em>i</em></sub>, <em>t</em>) − <em>t</em><sub><em>i</em></sub> ⋅ <em>P</em><sub><em>i</em></sub>(<em>v</em><sub><em>i</em></sub>, <em>t</em>)] ≥ 0⊥<em>γ</em><sub><em>i</em></sub>(<em>t</em>) ≥ 0</span></li></ol><p>这里<span class="math inline">⊥</span>表示RoS约束与<span class="math inline"><em>γ</em><sub><em>i</em></sub>(<em>t</em>)</span>非负性之间的互补条件，即两个不等式都成立且至少其中一个满足等号取等条件。注意严格的IC在<span class="math inline"><em>γ</em><sub><em>i</em></sub>(<em>t</em>) = 0</span> 时取到，其防止任何买家在任何时刻出现偏差（严格的IC并不保证RoS总能满足）。</p><p>当<span class="math inline"><em>I</em> = 0</span>（买家追求价值最大化）且<span class="math inline"><em>γ</em><sub><em>i</em></sub>(<em>t</em>) = 0</span>时条件一暗示<span class="math inline"><em>X</em><sub><em>i</em></sub>(<em>v</em><sub><em>i</em></sub>, <em>t</em><sub><em>i</em></sub>)</span>是独立于<span class="math inline"><em>v</em><sub><em>i</em></sub></span>的常量。另一方面<span class="math inline"><em>I</em> = 1</span>或<span class="math inline"><em>γ</em><sub><em>i</em></sub>(<em>t</em>) &gt; 0</span>时，条件一则可以被转化为：</p><ul><li>分配<span class="math inline"><em>X</em><sub><em>i</em></sub>(<em>v</em><sub><em>i</em></sub>, <em>t</em>)</span>在<span class="math inline"><em>v</em><sub><em>i</em></sub></span>上不是递减的。</li><li>对全部<span class="math inline"><em>v</em><sub><em>i</em></sub> ∈ 𝒱</span>，<span class="math inline">$P_i(v_i,t)=P_i(0,t)+\eta_i(t)\cdot(v_i\cdot X_i(v_i,t)-\in^{v_i}_0 X_i(z,t)dz),\eta_i(t)=(1+\gamma_i(t))/(I+\gamma_i(t)\cdot t_i)$</span>。（<span class="math inline"><em>I</em><em>C</em> − <em>v</em> − 支付</span>）</li></ul><p>接着考虑IC-t。当买家都如实汇报且回报率向量是<span class="math inline"><em>t</em></span>时，以<span class="math inline"><em>R</em><em>o</em><em>S</em><sub><em>i</em></sub>(<em>t</em>)</span>表示买家<span class="math inline"><em>i</em></span>的RoS，那么有：</p><p><br /><span class="math display">$$\begin{align*}RoS_i(t)=\begin{cases}    \mathbb{E}_{v_i}[v_i\cdot X_i(v_i,t)]/\mathbb{E}_{v_i}[P_i(v,t)] &amp;\text{if} \mathbb{E}_{v_i}[P_i(v,t)]&gt;0 \\    +\infty \text{otherwise}\end{cases}\end{align*}$$</span><br /></p><p>文章证明，对IC-v的机制，其也是IC-t的仅当对每个买家<span class="math inline"><em>i</em></span>与任何<span class="math inline"><em>t</em><sub> − <em>i</em></sub> ∈ 𝒯<sup><em>n</em> − 1</sup></span>，有：</p><ol type="1"><li><span class="math inline"><em>U</em><sub><em>i</em></sub>(<em>t</em><sub><em>i</em></sub>; <em>t</em><sub> − <em>i</em></sub>)</span>不随<span class="math inline"><em>t</em><sub><em>i</em></sub></span>增加而增长（防止用户谎报更高的回报率）</li><li>对<span class="math inline">$\hat{t_i}&lt;t_i$</span>，如果<span class="math inline">$U_i(\hat{t_i};(\hat{t_i},t_{-i}))&gt;U_i(t_i;(t_i,t_{-i}))$</span>那么<span class="math inline">$RoS_i(\hat{t_i},t_{-i})&lt;t_i$</span>（防止用户谎报更低的回报率）</li></ol><p>这两个条件指出当RoS常量不绑定时预期收入也是常数。</p><p><strong>估价公开而目标回报率私有</strong>时，买家只能谎报目标回报率，当真实回报率空间为<span class="math inline">(<em>t</em><sub><em>i</em></sub>, <em>t</em><sub> − <em>i</em></sub>)</span>而买家<span class="math inline"><em>i</em></span>汇报<span class="math inline">$\hat{t_i}$</span>时他的期望收益是<span class="math inline">$U_i(\hat{t_i};t)=\mathbb{E}_{v_i}[v_i\cdot X_i(v_i,(\hat{t_i},t_{-i}))-I\cdot P_i(v_i,(\hat{t_i},t_{-i}))]$</span>，且<span class="math inline">$\mathbb{E}_{v_i}[v_i\cdot X_i(v_i,(\hat{t_i},t_{-i}))-t_i\cdot P_i(v_i,(\hat{t_i},t_{-i}))]\geq0$</span>，否则效用恒定为<span class="math inline"> − ∞</span>。此时上述条件是充要的。</p><p><strong>估价与目标回报率都私有</strong>时，为了使条件充要，文章提供了进一步的限制条件，其依赖于前述的证书函数：考虑机制的证书函数<span class="math inline">{<em>γ</em><sub><em>i</em></sub>}<sub><em>i</em> ∈ [<em>n</em>]</sub></span>，其是IC-t当且仅当对每个买家<span class="math inline"><em>i</em></span>与任何<span class="math inline"><em>t</em><sub> − <em>i</em></sub> ∈ 𝒯<sup><em>n</em> − 1</sup></span>有<span class="math inline">$\frac{\partial U_i(t_i;(t_i,t_{-i}))}{\partial t_i}=-\frac{\gamma_i(t_i,t_{-i})\cdot U_i(t_i;(t_i,t_{-i}))}{t_i-I}$</span>，如果<span class="math inline"><em>t</em></span>是可微点。</p><p>文章指出当机制是IC-v的时，最佳的投标策略总是采取统一乘法投标（uniform(multiplicative) bidding），也就是说考虑常量<span class="math inline"><em>β</em> &gt; 0</span>，总是去投标<span class="math inline"><em>β</em> ⋅ <em>v</em><sub><em>i</em></sub></span>。形式化地，对任何<span class="math inline">$\hat{v_i}\in\mathcal{T},v\in\mathcal{T}^n$</span>，存在最佳的投标策略<span class="math inline"><em>α</em></span>，<span class="math inline"><em>α</em>(<em>v</em>) = <em>β</em> ⋅ <em>v</em></span>，其中<span class="math inline"><em>v</em> ∈ 𝒱, <em>β</em> &gt; 0</span>为常量，这一策略可以实现<span class="math inline">$U_i(\hat{t_i};t)$</span>。</p><p>这一乘数可以被计算得出。更具体的，令<span class="math inline">$margin(\beta,\phi;\hat{t_i},t)=\mathbb{E}_{v_i}[v_i\cdot X_i(\beta\cdot v_i,(\hat{t_i};t_{-i}))-\phi\cdot P_i(\beta\cdot v_i,(\hat{t_i},t_{-i}))]$</span>，其中<span class="math inline"><em>β</em> &gt; 0, <em>ϕ</em> &gt; 0</span>。当<span class="math inline">$\gamma_i(\hat{t_i},t_{-i})&gt;0$</span>或<span class="math inline"><em>T</em> &gt; 0</span>时，<span class="math inline"><em>m</em><em>a</em><em>r</em><em>g</em><em>i</em><em>n</em>(<em>β</em>, <em>ϕ</em>)</span>就<span class="math inline"><em>β</em></span>而言是单峰的。换言之，可以首先计算可行域<span class="math inline">$[\underline{\beta},\overline{\beta}]$</span>使得对<span class="math inline">$\forall\beta\in[\underline{\beta},\overline{\beta}]$</span>都有<span class="math inline">$margin(\beta,\phi;\hat{t_i},t)&gt;0$</span>。从而，乘数可以由计算<span class="math inline">$\forall\beta\in[\underline{\beta},\overline{\beta}]$</span>间使得<span class="math inline">$margin(\beta,\phi;\hat{t_i},t)&gt;0$</span>最大的数而得到。</p><h3 id="最大化价值者的收入最优拍卖">最大化价值者的收入最优拍卖</h3><ol type="1"><li>对<strong>价值公开而目标回报率私有</strong>的情况，适用于最大化价值者的收入最优拍卖应是如下的机制：<span class="math inline">$x_i(v,t)=1\{i=\argmax_{j:v_j/t_j&gt;c}v_j/t_j\},p_i(v,t)=v_i/t_i \cdot x_i(v,t)$</span>。</li><li>对<strong>价值私有而目标回报率公开</strong>的情况，机制则是如下的形式：<span class="math inline">$x_i(v,t)=1\{i=\argmax_{j:v_j/t_j&gt;c}v_j/t_j\},p_i(v,t)=\frac{1+\gamma_i(t)}{\gamma_i(t)}\cdot x_i(v,t)\cdot\max\{c,\max_{j\neq i} v_j/t_j\}$</span>，<span class="math inline"><em>γ</em><sub><em>i</em></sub></span>应使得<span class="math inline">𝔼<sub><em>v</em><sub><em>i</em></sub></sub>[<em>v</em><sub><em>i</em></sub> ⋅ <em>X</em><sub><em>i</em></sub>(<em>v</em><sub><em>i</em></sub>, <em>t</em>) − <em>t</em><sub><em>i</em></sub> ⋅ <em>P</em><sub><em>i</em></sub>(<em>v</em><sub><em>i</em></sub>, <em>t</em>)] = 0</span>。</li></ol><p>如前所述，情况一类似于有底价的一价拍卖，而情况二则类似于维克利拍卖（二价拍卖），两种情况下买家都被按目标调整价值排序，且支付都应满足RoS约束。文章证明本机制是IC-t的，并能获得第一最佳收入。另一方面，如果价值与目标回报率都私有，那么追求收入最优的拍卖机制无法实现第一最佳收入。</p><h3 id="最大化效用者的收入最优拍卖">最大化效用者的收入最优拍卖</h3><h4 id="价格公开目标回报率私有">价格公开，目标回报率私有</h4><p>方便起见，记<span class="math inline"><em>U</em>(<em>t</em>) = <em>U</em>(<em>t</em>; <em>t</em>)</span>。令<span class="math inline"><em>ϕ</em>(<em>w</em>) = min<sub><em>x</em></sub>𝔼<sub><em>v</em></sub>[<em>x</em>(<em>v</em>, <em>t</em>)]s.t. 𝔼<sub><em>v</em></sub>[<em>v</em> ⋅ <em>x</em>(<em>v</em>, <em>t</em>)] = <em>w</em></span>表示能向买方提供预期价值<span class="math inline"><em>w</em></span>的最低预期分配。文章将收入最大化的问题视作一个优化问题，其中<span class="math inline"><em>U</em>(<em>T</em>)</span>为唯一的决定性变量。由于关于IC-t的表述是充要的，因而最大化的方程可以写作：</p><p><br /><span class="math display">$$\begin{align*}    \max_{x,p}\mathbb{E}_{t,v}[p(v,t)-c\cdot x(v,t)] \\    \text{s.t. }\mathbb{E}_v[v\cdot x(v,t) - t\cdot p(v,t)] \geq 0, \forall t \in \mathcal{T}, \\    U(t)=\mathbb{E}_v[v\cdot x(v,t) - p(v,t)]\text{不增且不为负}\end{align*}$$</span><br /></p><p>由此，通过解决这一优化问题，文章为最大化效用者提供了一种最优的拍卖机制：</p><p>令阈值<span class="math inline">$\underline{t}\geq\overline{t}$</span>满足<span class="math inline">$\overline{t}=\argmax_{t\geq t^{\max}} Rev(t),w^*=\frac{\underline{t}}{\underline{t}-1}\cdot U^*(\overline{t})$</span>，其中有：</p><p><br /><span class="math display">$$\begin{align*}    Q(w) &amp;= w - c\cdot \phi(w)\\    w^* &amp;=\argmax_{0\leq w\leq\mathbb{E}_v[v]} Q(w)\\    U^*(t) &amp;= \argmax_u Q(\min\{w^*\frac{t}{t-1}\cdot u\})-u \\    Rev(t) &amp;= \int^t_1 (Q(\min\{w^*,\frac{z}{z-1}\cdot U^*(t)\})-U^*(t))\cdot g(z)dz \\    &amp;+ \int^{\infty}_t(Q(\min\{w^*,\frac{z}{z-1}\cdot U^*(z)\})-U^*(z))\cdot g(z)dz\end{align*}$$</span><br /></p><p>定义乘数函数<span class="math inline">$r:[\underline{t},\overline{t}]\rightarrow \mathbb{R}_{\geq 0}$</span>对任意<span class="math inline">$t\in[\underline{t},\overline{t}]$</span>有<span class="math inline">$\mathbb{E}_v[v\cdot1\{v/r(t)&gt;c\}]=\frac{t}{t-1}\cdot U^*(\overline{t})$</span>。最优的机制可以被如下导出：</p><p><br /><span class="math display">$$\begin{align*}    x(v,t) &amp;= \begin{cases}        1\{v&gt;c\} &amp; \text{if }t\in[1,\underline{t}] \\        1\{v/r(t)&gt;c\} &amp; \text{if }t\in[\underline{t},\overline{t}] \\        1\{v/t&gt;c\} &amp; \text{if }t\in[\overline{t},\infty)     \end{cases} \\    p(v,t) &amp;= \begin{cases}        v/\underline{t}\cdot x(v,t) &amp; \text{if }t\in[1,\underline{t}] \\        v/t\cdot x(v,t) &amp; \text{if }t\in[\underline{t},\overline{t}] \\        v/t\cdot x(v,t) &amp; \text{if }t\in[\overline{t},\infty)     \end{cases}\end{align*}$$</span><br /></p><h4 id="价格私有目标回报率公开">价格私有，目标回报率公开</h4><figure><img src="https://pikapikapikaori.github.io/pikapikapi-blog/archive/ITtech/_media/PaperReading-202309-20230920/picture-2.png" alt="" /><figcaption>picture</figcaption></figure><h2 id="参考资料">参考资料</h2><ol type="1"><li>Balseiro, S., Deng, Y., Mao, J., Mirrokni, V., &amp; Zuo, S. (2021). The Landscape of Auto-Bidding Auctions: Value Versus Utility Maximization. SSRN Electronic Journal. https://doi.org/10.2139/ssrn.3785579</li></ol>]]></content>
    <pubDate>Sat, 13 Apr 2024 14:30:34 +0800</pubDate>
  </entry>
   
  <entry>
    <title><![CDATA[论文阅读 2023.08]]></title>
    <link>https://pikapikapikaori.github.io/pikapikapi-blog/#/archive/ITtech/PaperReading-202308-20230810</link>
    <guid isPermaLink="false">https://pikapikapikaori.github.io/pikapikapi-blog/#/archive/ITtech/PaperReading-202308-20230810</guid>
    <content type="html"><![CDATA[<h1 id="论文阅读-2023.08">论文阅读 2023.08</h1><blockquote><p>本文首发于个人博客<br />发表日期：2023.09.03<br />最后编辑于：{docsify-last-updated}</p></blockquote><h2 id="one-dollar-each-eliminates-envy">One Dollar Each Eliminates Envy</h2><blockquote><p>Brustle, J., Dippel, J., Narayan, V. V., Suzuki, M., &amp; Vetta, A. (2020, July 13). One Dollar Each Eliminates Envy. Proceedings of the 21st ACM Conference on Economics and Computation. https://doi.org/10.1145/3391403.3399447</p></blockquote><p>文章着眼于研究<span class="math inline"><em>m</em></span>个不可分割的商品在<span class="math inline"><em>n</em></span>个代理人间进行无嫉妒分配的问题。当然通常这是不可能的，但是可以通过引入一定数量的可分割商品来达到EF分配。文章证明给予每个代理人最多一美元（一个单位价值）的补贴就足以保证可无嫉妒的分配存在，且补贴总和最多为<span class="math inline"><em>n</em> − 1</span>单位价值。此时，这种分配同时也是EF1的，且这种分配是平衡的，换言之分配的束的数量最多差一。同时文章还证明，对于一般的单调估价函数，始终存在EF分配使得每个代理人最多获得<span class="math inline">2(<em>n</em> − 1)</span>单位价值的补贴，此时补贴总和为<span class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span>。注意这里的估价函数都为可加性函数。</p><p><em>个人感觉结论直觉上还挺显然的，最大的价值可能在于证明了补贴可以足够小。</em></p><h3 id="基础概念ef分配及其他">基础概念：EF分配及其他</h3><ul><li>EF分配（Envy-free item allocation）：考虑两个参与者A与B，其拥有的物品束分别为X和Y。EF分配指对任何参与者，其认为其持有的物品束的价值总和不小于另一个参与人的物品束价值总和。</li><li>EF1分配：EF1分配指当从某一个参与人的物品束中移除最多一个物品后可以使得另一个参与人无嫉妒。</li><li>EFx分配：EFx分配指当从某一个参与人的物品束中移除任意多个任意物品后可以使得另一个参与人无嫉妒。显然有EF分配强于EFx分配强于EF1分配：EF1分配要求移除最大价值的物品，而EFx分配只要求移除最小价值的物品。</li><li>部分EF分配：部分指明不是全部物品都需要被分配给参与者。</li><li>纳什社会福利（Nash social welfare）：当满足帕累托最优，社会福利函数不依赖于个体，匿名性与连续性的情况下，可以导出的特殊的社会福利函数即为纳什社会福利函数。注意这里社会福利函数可以被视为个人福利的总和，个人福利以效用水平表示。</li><li>可加性估值函数：表明对商品束而言，商品束的估价可以被视为商品束内全部商品估价的总和。</li></ul><h3 id="无嫉妒分配模型与已有结论">无嫉妒分配模型与已有结论</h3><p>考虑参与者集合<span class="math inline"><em>I</em> = {1, 2, ⋯, <em>n</em>}</span>与不可分割商品构成的商品束<span class="math inline"><em>J</em> = {1, 2, ⋯, <em>m</em>}</span>。每个代理人<span class="math inline"><em>i</em> ∈ <em>I</em></span>都对商品束中的商品存在估值（估价）函数<span class="math inline"><em>v</em><sub><em>i</em></sub></span>使得商品束<span class="math inline"><em>S</em> ⊆ <em>J</em></span>对代理人<span class="math inline"><em>i</em></span>有价值<span class="math inline"><em>v</em><sub><em>i</em></sub>(<em>S</em>)</span>。在文章中假设这一估值函数是单调可加的，换言之，如果<span class="math inline"><em>S</em> ⊆ <em>T</em></span>那么有<span class="math inline"><em>v</em><sub><em>i</em></sub>(<em>S</em>) ≤ <em>v</em><sub><em>i</em></sub>(<em>T</em>), <em>v</em><sub><em>i</em></sub>(∅) = 0</span>,同时对<span class="math inline"><em>S</em> ⊆ <em>J</em></span>与<span class="math inline"><em>j</em> ∈ <em>J</em>, <em>v</em><sub><em>i</em></sub>(<em>j</em>) = <em>v</em><sub><em>i</em></sub>({<em>j</em>})</span>有<span class="math inline"><em>v</em><sub><em>i</em></sub>(<em>S</em>) = ∑<sub><em>j</em> ∈ <em>S</em></sub><em>v</em><sub><em>i</em></sub>(<em>j</em>)</span>。全部代理人的估值函数构成估值概要（valuation profile）<span class="math inline"><em>v</em> = (<em>v</em><sub>1</sub>, ⋯, <em>v</em><sub><em>n</em></sub>)</span>，同时为了便于计算对每个估值函数进行缩放使得任何物品<span class="math inline"><em>j</em></span>的最大边际价值为1（美元/单位价值）。</p><p>一个分配<span class="math inline">𝒜 = {<em>A</em><sub>1</sub>, ⋯, <em>A</em><sub><em>n</em></sub>}</span>是将商品集合划分为<span class="math inline"><em>n</em></span>个商品束的有序划分，第<span class="math inline"><em>i</em></span>个参与者获得商品束<span class="math inline"><em>A</em><sub><em>i</em></sub></span>（可以为空）。如果<span class="math inline">∀<em>i</em> ∈ <em>I</em>, ∀<em>k</em> ∈ <em>I</em>, <em>v</em><sub><em>i</em></sub>(<em>A</em><sub><em>i</em></sub>) ≥ <em>v</em><sub><em>i</em></sub>(<em>A</em><sub><em>k</em></sub>)</span>那么称其为无嫉妒的。</p><p>另一方面，对于每一对参与人<span class="math inline"><em>i</em>, <em>k</em></span>，如果要么<span class="math inline"><em>A</em><sub><em>k</em></sub> = ∅</span>，要么存在<span class="math inline"><em>j</em> ∈ <em>A</em><sub><em>k</em></sub></span>使得<span class="math inline"><em>v</em><sub><em>i</em></sub>(<em>A</em><sub><em>i</em></sub>) ≥ <em>v</em><sub><em>i</em></sub>(<em>A</em><sub><em>k</em></sub>\{<em>j</em>})</span>，那么称此时的分配是EF1的。</p><p>由于EF分配并不总能达到，在文章考虑的模型中可以通过引入非负向量<span class="math inline"><em>p</em> = (<em>p</em><sub>1</sub>, ⋯, <em>p</em><sub><em>n</em></sub>)</span>使得第<span class="math inline"><em>i</em></span>个参与者获得补贴<span class="math inline"><em>p</em><sub><em>i</em></sub> ≥ 0</span>。那么当<span class="math inline">∀<em>i</em> ∈ <em>I</em>, ∀<em>k</em> ∈ <em>I</em>, <em>v</em><sub><em>i</em></sub>(<em>A</em><sub><em>i</em></sub>) + <em>p</em><sub><em>i</em></sub> ≥ <em>v</em><sub><em>i</em></sub>(<em>A</em><sub><em>k</em></sub>) + <em>p</em><sub><em>k</em></sub></span>时称分配<span class="math inline">(𝒜, <em>p</em>)</span>为无嫉妒的。注意对于固定分配<span class="math inline"><em>A</em></span>而言并不总存在<span class="math inline"><em>p</em></span>使得<span class="math inline">(𝒜, <em>p</em>)</span>无嫉妒，因而能达到无嫉妒的分配<span class="math inline">𝒜</span>被称为可无嫉妒的（envy-freeable）。</p><p>更形象的，对于分配<span class="math inline">𝒜</span>，其嫉妒图<span class="math inline"><em>G</em><sub>𝒜</sub></span>是一个顶点集为<span class="math inline"><em>I</em></span>的完全有向图，其中任意一对节点<span class="math inline"><em>i</em>, <em>k</em> ∈ <em>I</em></span>的弧<span class="math inline"><em>a</em><em>r</em><em>c</em>(<em>i</em>, <em>k</em>)</span>的权重是分配<span class="math inline">𝒜</span>下<span class="math inline"><em>i</em></span>对<span class="math inline"><em>k</em></span>的嫉妒，即<span class="math inline"><em>w</em><sub>𝒜</sub>(<em>i</em>, <em>k</em>) = <em>v</em><sub><em>i</em></sub>(<em>A</em><sub><em>k</em></sub>) − <em>v</em><sub><em>i</em></sub>(<em>A</em><sub><em>i</em></sub>)</span>。当且仅当图中不存在正权有向环时分配才是可无嫉妒的，此时分配<span class="math inline">𝒜</span>在商品束的所有分配中最大化了社会福利，即对<span class="math inline"><em>I</em> = [<em>n</em>]</span>的全部排列<span class="math inline"><em>π</em></span>，有<span class="math inline">∑<sub><em>i</em> ∈ <em>I</em></sub><em>v</em><sub><em>i</em></sub>(<em>A</em><sub><em>i</em></sub>) ≥ ∑<sub><em>i</em> ∈ <em>I</em></sub><em>v</em><sub><em>i</em></sub>(<em>A</em><sub><em>π</em>(<em>i</em>)</sub>)</span>（结论出自论文《Fair Division with Subsidy》）。</p><p>这一结论提供了计算最少补贴的方式：首先找到最大化社会福利的分配，并接着在其所对应的嫉妒图中计算从每个节点开始的最大权重路径。另一方面补贴只需要提供给最多<span class="math inline"><em>n</em> − 1</span>个人。由此可以得到以下推论：</p><p><strong>推论：</strong>对于任意可无嫉妒的分配<span class="math inline">𝒜</span>，所需要的最小补贴最大为<span class="math inline">(<em>n</em> − 1) ⋅ <em>l</em><sub><em>G</em><sub>𝒜</sub></sub><sup>max</sup></span>，其中<span class="math inline"><em>l</em><sub><em>G</em><sub>𝒜</sub></sub><sup>max</sup></span>是嫉妒图<span class="math inline"><em>G</em><sub>𝒜</sub></span>中有向路径的最大权重，并有<span class="math inline"><em>l</em><sub><em>G</em><sub>𝒜</sub></sub><sup>max</sup> ≤ <em>m</em></span>。</p><h3 id="构建权重为1的最大路径的分配的算法">构建权重为1的最大路径的分配的算法</h3><p>考虑顶点集<span class="math inline"><em>I</em>, <em>J</em></span>上的完全二分图<span class="math inline"><em>H</em></span>是估值图，其中边<span class="math inline">(<em>i</em>, <em>j</em>)</span>的权重为<span class="math inline"><em>v</em><sub><em>i</em></sub>(<em>j</em>)</span>。用<span class="math inline"><em>h</em>[<em>Î</em>, <em>Ĵ</em>]</span>表示从<span class="math inline"><em>H</em></span>导出的子图。分配算法在每一轮中将一个项目匹配给参与者。一开始，令<span class="math inline"><em>J</em><sub>1</sub> = <em>J</em></span>。在第<span class="math inline"><em>t</em></span>轮。首先寻找<span class="math inline"><em>H</em>[<em>I</em>, <em>J</em><sub><em>t</em></sub>]</span>中的最大匹配权重<span class="math inline"><em>M</em><sub><em>t</em></sub></span>（找权重最大的边），如果参与者<span class="math inline"><em>i</em></span>与商品<span class="math inline"><em>j</em> = <em>μ</em><sub><em>i</em></sub><sup><em>t</em></sup></span>匹配，那么将该商品分配给盖参与者。接着在剩余的商品束<span class="math inline"><em>J</em><sub><em>t</em> + 1</sub> = <em>J</em><sub><em>t</em></sub>\∪<sub><em>i</em> ∈ <em>I</em></sub><em>μ</em><sub><em>i</em></sub><sup><em>t</em></sup></span>中进行递归。</p><figure><img src="https://pikapikapikaori.github.io/pikapikapi-blog/archive/ITtech/_media/PaperReading-202308-20230810/picture-1.png" title="分配算法" alt="" /><figcaption>picture</figcaption></figure><p>文章接着证明了该分配是可无嫉妒的，并且是EF1的。同时，分配也是平衡的，换言之分配的束的数量最多差一，事实上每个参与者获得的商品束的大小为<span class="math inline">$\lceil\frac{m}{n}\rceil$</span>或<span class="math inline">$\lfloor\frac{m}{n}\rfloor$</span>。分配算法则在多项式时间内运行。</p><p>另一方面，文章还证明了任何可无嫉妒的且为EF1的分配都在嫉妒图中有最大权重路径，且该权重最大为<span class="math inline"><em>n</em> − 1</span>。文章接着证明了算法给出的分配事实上权重最大为1，因此所需的补贴最大为<span class="math inline"><em>n</em> − 1</span>。</p><p>更具体的，令<span class="math inline">𝒜<sup><em>v</em></sup> = {<em>A</em><sub>1</sub><sup><em>v</em></sup>, ⋯, <em>A</em><sub><em>n</em></sub><sup><em>v</em></sup>}</span>是算法给出的分配，首先从原有的估值概要构造出新的估值函数：对每个参与者<span class="math inline"><em>i</em></span>，有：</p><p><br /><span class="math display">$$\begin{align*}\bar{v_i}(\mu^t_i) &amp;= v_i(\mu^t_i),\ \forall t\leq T\\\bar{v_i}(\mu^t_k) &amp;= \max(v_i(\mu^t_k),v_i(\mu^{t+1}_i)),\ \forall k\in I\text{\textbackslash}\{i\},\ \forall t \leq T-1 \\\bar{v_i}(\mu^T_k) &amp;= v_i(\mu^T_k),\ \forall k\in I\text{\textbackslash}\{i\}\end{align*}$$</span><br /></p><p>换言之，参与人<span class="math inline"><em>i</em></span>对分配给参与人<span class="math inline"><em>i</em></span>的物品的估值不变，而对于其他物品<span class="math inline"><em>j</em></span>，参与人<span class="math inline"><em>i</em></span>对其的估值为下面两者的较大值：</p><ol type="1"><li>参与人<span class="math inline"><em>i</em></span>对其的原始估值。</li><li>在分配物品<span class="math inline"><em>j</em></span>的下一轮中，参与人<span class="math inline"><em>i</em></span>对分配给参与人<span class="math inline"><em>i</em></span>的物品的估值。</li></ol><p>文章证明了在进行这种对估值函数的改变后，可以发现最大权重路径的权重最大为1，因此所需的补贴最大为<span class="math inline"><em>n</em> − 1</span>。</p><h2 id="bayesian-and-randomized-clock-auctions">Bayesian and Randomized Clock Auctions</h2><blockquote><p>Feldman, M., Gkatzelis, V., Gravin, N., &amp; Schoepflin, D. (2022, July 12). Bayesian and Randomized Clock Auctions. Proceedings of the 23rd ACM Conference on Economics and Computation. https://doi.org/10.1145/3490486.3538247</p></blockquote><p>文章主要研究了确定性贝叶斯时钟拍卖与随机先验无关（prior-free，参与者的估值并不可知）时钟拍卖的一些性质。更具体的，文章同样着眼于社会福利最大化（全部买家对自己获得物品的估值之和最大化），并分析多种情况下（对先验信息的可知性）如何设置时钟拍卖以使得其能够保证近似最优的社会福利。</p><h3 id="基本的时钟拍卖模型">基本的时钟拍卖模型</h3><p><span class="math inline"><em>n</em></span>个购买人组成的集合<span class="math inline"><em>N</em></span>需要某种服务，每个买家<span class="math inline"><em>i</em></span>都有一个表明他本人购买欲望的私有估值<span class="math inline"><em>v</em><sub><em>i</em></sub></span>，其组成了估值空间<span class="math inline"><em>v</em> = (<em>v</em><sub><em>i</em></sub>)<sub><em>i</em> ∈ <em>N</em></sub></span>。可行性约束<span class="math inline">ℱ ⊆ 2<sup><em>N</em></sup></span>包含了可以同时服务的买家子集。本模型关注于向下封闭的可行约束，也就是说如果<span class="math inline"><em>F</em> ∈ ℱ</span>那么对<span class="math inline">∀<em>F</em>′ ∈ <em>F</em></span>总有<span class="math inline"><em>F</em>′ ∈ ℱ</span>。更形象的说，如果买家集合<span class="math inline"><em>F</em></span>可以被服务，那么其任意子集也可以被服务。</p><p>向下封闭的可行约束集合的两个较典型的例子是不相交最大集（Disjoint-Maximal-Sets）和Knapsack：</p><ul><li>不相交最大集：全部买家被划分为<span class="math inline"><em>k</em></span>个不相交的子集<span class="math inline"><em>S</em><sub>1</sub>, ⋯, <em>S</em><sub><em>k</em></sub></span>，一组买家的集合<span class="math inline"><em>F</em></span>只能是这组子集其中之一的子集（被称为可行的，feasible），即<span class="math inline">ℱ = {<em>F</em> ⊆ <em>N</em>|∃<em>S</em><sub><em>j</em></sub> s.t. <em>F</em> ⊆ <em>S</em><sub><em>j</em></sub>}</span></li><li>Knapsack：每个买家<span class="math inline"><em>i</em></span>有一个需求的大小<span class="math inline"><em>c</em><sub><em>i</em></sub></span>，拍卖者应所能提供的服务不应小于被提供的买家集合的需求大小的加和。注意买家需求的大小与所能提供服务的大小可以进行统一放缩，因而有<span class="math inline">ℱ = {<em>F</em> ⊆ <em>N</em>|∑<sub><em>i</em> ∈ <em>F</em></sub><em>c</em><sub><em>i</em></sub> ≤ 1}</span></li></ul><p>拍卖模型的目标是设计一个拍卖系统，使得其可以为一组可行（feasible）的买家集合提供服务，并保证能够最大化社会福利，这里社会福利被定义为<span class="math inline"><em>S</em><em>W</em>(<em>F</em>) = ∑<sub><em>i</em> ∈ <em>F</em></sub><em>v</em><sub><em>i</em></sub></span>。在贝叶斯情况下每个买家<span class="math inline"><em>i</em></span>的估值<span class="math inline"><em>v</em><sub><em>i</em></sub></span>由<span class="math inline"><em>D</em><sub><em>i</em></sub></span>导出，全部买家的分布可以被表示为<span class="math inline">$\bold{D}=\times_{i\in N}D_i$</span>，方便起见用<span class="math inline">$\underset{v\sim \bold{D}}{E}[AUC]$</span>表示拍卖<span class="math inline"><em>A</em><em>U</em><em>C</em></span>的期望社会福利，并利用预期最优社会福利<span class="math inline">$OPT=\underset{v\sim \bold{D}}{E}[\max_{F\in\mathcal{F}}\{\sum_{i\in F}v_i\}]$</span>来评估贝叶斯时钟拍卖的性能。如果对每个分布<span class="math inline">$\bold{D}$</span>有<span class="math inline"><em>O</em><em>P</em><em>T</em> ≤ <em>α</em> ⋅ <em>A</em><em>U</em><em>C</em></span>那么称拍卖<span class="math inline"><em>A</em><em>U</em><em>C</em></span>能够以<span class="math inline"><em>α</em></span>因子近似于最优社会福利。</p><p>时钟拍卖是一种多轮机制，每个投标人都会得到一个定制化的时钟价格，也就是说价格会随时间推移而轻微增长。拍卖开始是，所有投标人都是活跃的（active）。初始价格空间<span class="math inline">$\bold{p}^1=\{p^1_i\}^n_{i=1}$</span>被发布给投标人，每个投标人可以选择永久退出拍卖或继续以当前价格保持活跃。每一轮<span class="math inline"><em>t</em></span>中，拍卖师向每个活跃的投标者<span class="math inline"><em>i</em></span>发布新的价格<span class="math inline"><em>p</em><sub><em>i</em></sub><sup><em>t</em></sup> ≥ <em>p</em><sub><em>i</em></sub><sup><em>t</em> − 1</sup></span>，而投标者可以选择继续保持活跃或永久退出。如果在第<span class="math inline"><em>γ</em></span>轮剩下的投标者能形成可行集合<span class="math inline"><em>F</em> ∈ ℱ</span>那么久结束拍卖，此时每个剩下的活跃的投标者<span class="math inline"><em>i</em></span>以价格<span class="math inline"><em>p</em><sub><em>i</em></sub><sup><em>γ</em></sup></span>获得服务，而退出的投标者则不会获得服务也不需要支付。每轮中的价格信息都被公开，例如价格历史记录、投标人对价格的反应，以及可行结构等。</p><p>相较于传统的密闭拍卖，时钟拍卖有以下好处：</p><ol type="1"><li>在密闭拍卖中，投标人需要将价格告知拍卖师，然而投标人往往不能准确回报他的估值</li><li>时钟拍卖中投标人不需要告知拍卖师他的估值，保障了隐私</li><li>时钟拍卖更具可信性</li><li>拍卖本身也较为简单</li></ol><h3 id="有先验信息的确定性单价时钟拍卖">有先验信息的确定性单价时钟拍卖</h3><p>文章首先研究了最简单的时钟拍卖，即单价时钟拍卖。这种拍卖不要去每个投标人对不断增加的价格报价作出回应，而是为每个投标人提供一个价格。每个投标人可以在不同的时间获得该价格信息并对其做出回应。随后机制收集所有人对价格的回应，并决定最终服务哪个子集。</p><figure><img src="https://pikapikapikaori.github.io/pikapikapi-blog/archive/ITtech/_media/PaperReading-202308-20230810/picture-2.png" title="单价时钟拍卖" alt="" /><figcaption>picture</figcaption></figure><p>文章考虑向下封闭的可行约束<span class="math inline">ℱ</span>中的最大可行集<span class="math inline">𝒮 = <em>S</em><sub>1</sub>, ⋯, <em>S</em><sub><em>k</em></sub></span>，并证明由于有先验信息，因而可以设计出一个单价时钟拍卖，使得其能达到<span class="math inline"><em>O</em>(log log <em>k</em>)</span>的近似最优社会福利。</p><p>文章首先指出，有先验信息（即估值的分布<span class="math inline">$\bold{D}$</span>）的单价时钟拍卖实质上借鉴了先知不等式（prophet inequality）的研究，其很接近于有序先知模型（机制设计者有序的选择接触的买家的顺序，并向其提供价格）。</p><p>更具体的，可以采取以下策略来实现近似最优：</p><p>定义集合<span class="math inline">$S(t,v)\overset{def}{=}\{i\in S|v_i&gt;t\}$</span>，首先可以计算出阈值<span class="math inline"><em>t</em><sub><em>S</em></sub></span>使得<span class="math inline"><em>E</em><sub><em>v</em></sub>[|<em>S</em>(<em>t</em><sub><em>S</em></sub>, <em>v</em>)|] = log <em>k</em></span>。</p><ol type="1"><li>要么单价格为<span class="math inline">0</span></li><li>要么选择<span class="math inline"><em>j</em> ∈ [0, log (10log <em>k</em> + 1)]</span>并将单价格设置为<span class="math inline"><em>Δ</em> ⋅ 2<sup>1 − <em>j</em></sup></span>，其中<span class="math inline"><em>Δ</em> = <em>E</em>[max<sub><em>S</em> ∈ 𝒮</sub>(∑<sub><em>i</em> ∈ <em>S</em></sub><em>v</em><sub><em>i</em></sub> ⋅ 𝕀[<em>v</em><sub><em>i</em></sub> ≥ <em>t</em><sub><em>s</em></sub>] ⋅ 𝕀[|<em>S</em>(<em>t</em><sub><em>S</em></sub>, <em>v</em>)| ≤ 10log <em>k</em> + 1])]</span>。这里形如<span class="math inline">𝕀[]</span>的函数均为指示函数，内部为真时导出值<span class="math inline">1</span>，否则导出值<span class="math inline">0</span></li></ol><h3 id="有限信息的确定性时钟拍卖">有限信息的确定性时钟拍卖</h3><p>这里考虑的是对估值的分布<span class="math inline">$\bold{D}$</span>仅知道其有关的部份信息。为了达到近似最佳，首先可以检察是否存在最大可行集<span class="math inline"><em>S</em> ∈ 𝒮</span>使得其期望值至少为<span class="math inline">$\frac{OPT}{\log\log k}$</span>，如果存在那么可以通过接受该集合中的所有投标人（价格0）来达到近似最佳的目的。相反若不存在，那么可以使用一个任意小的步长<span class="math inline"><em>δ</em> &gt; 0</span>来统一提高每个活跃投标人的价格，使得他们有机会在每次价格上涨后退出。简单起见可以为所有投标人同时提供该价格，但在实践中以任意的顺序向每个投标人提供增加后的价格。同样当剩下的活跃投标人可行或其子集可行并达到预期的近似最优时拍卖结束。注意算法中<span class="math inline">$\mathcal{g}=\frac{OPT}{4\alpha},\alpha=O(\log\log k)$</span>。</p><figure><img src="https://pikapikapikaori.github.io/pikapikapi-blog/archive/ITtech/_media/PaperReading-202308-20230810/picture-3.png" title="有限信息的确定性时钟拍卖" alt="" /><figcaption>picture</figcaption></figure><p>文章证明这一机制仅需利用<span class="math inline"><em>E</em>[<em>v</em><sub><em>i</em></sub>], ∀<em>i</em> ∈ <em>N</em></span>和<span class="math inline"><em>O</em><em>P</em><em>T</em> = <em>E</em><sub><em>v</em></sub>[max<sub><em>S</em> ∈ 𝒮</sub>∑<sub><em>i</em> ∈ <em>S</em></sub><em>v</em><sub><em>i</em></sub>]</span>即可达到<span class="math inline"><em>O</em>(log log <em>k</em>)</span>的近似最优社会福利。</p><h3 id="随机先验无关时钟拍卖randomized-prior-free-clock-auction">随机先验无关时钟拍卖（Randomized Prior-Free Clock Auction）</h3><p>文章最后考虑了无先验信息的情况，并指出可以通过牺牲简单性与实用性来达到近似最佳。</p><figure><img src="https://pikapikapikaori.github.io/pikapikapi-blog/archive/ITtech/_media/PaperReading-202308-20230810/picture-4.png" title="注水时钟拍卖" alt="" /><figcaption>picture</figcaption></figure><figure><img src="https://pikapikapikaori.github.io/pikapikapi-blog/archive/ITtech/_media/PaperReading-202308-20230810/picture-5.png" title="样品拍卖" alt="" /><figcaption>picture</figcaption></figure><figure><img src="https://pikapikapikaori.github.io/pikapikapi-blog/archive/ITtech/_media/PaperReading-202308-20230810/picture-6.png" title="随机先验无关时钟拍卖：对冲拍卖" alt="" /><figcaption>picture</figcaption></figure><p>文章指出，通过结合WFCA与抽样拍卖，能够期望其发挥两者的优势，以达到目标的近似值。</p><h2 id="参考资料">参考资料</h2><ol type="1"><li>Brustle, J., Dippel, J., Narayan, V. V., Suzuki, M., &amp; Vetta, A. (2020, July 13). One Dollar Each Eliminates Envy. Proceedings of the 21st ACM Conference on Economics and Computation. https://doi.org/10.1145/3391403.3399447</li><li>Kaneko, M., &amp; Nakamura, K. (1979, March). The Nash Social Welfare Function. Econometrica, 47(2), 423. https://doi.org/10.2307/1914191</li><li>Halpern, D., &amp; Shah, N. (2019). Fair Division with Subsidy. Algorithmic Game Theory, 374–389. https://doi.org/10.1007/978-3-030-30473-7_25</li><li>Feldman, M., Gkatzelis, V., Gravin, N., &amp; Schoepflin, D. (2022, July 12). Bayesian and Randomized Clock Auctions. Proceedings of the 23rd ACM Conference on Economics and Computation. https://doi.org/10.1145/3490486.3538247</li><li>Christodoulou, G., Gkatzelis, V., &amp; Schoepflin, D. (2022). Optimal Deterministic Clock Auctions and Beyond. In 13th Innovations in Theoretical Computer Science Conference (ITCS 2022) (pp. 49:1–49:23). Schloss Dagstuhl – Leibniz-Zentrum fur Informatik.</li></ol>]]></content>
    <pubDate>Sat, 13 Apr 2024 14:30:34 +0800</pubDate>
  </entry>
   
  <entry>
    <title><![CDATA[论文阅读 2023.07]]></title>
    <link>https://pikapikapikaori.github.io/pikapikapi-blog/#/archive/ITtech/PaperReading-202307-20230701</link>
    <guid isPermaLink="false">https://pikapikapikaori.github.io/pikapikapi-blog/#/archive/ITtech/PaperReading-202307-20230701</guid>
    <content type="html"><![CDATA[<h1 id="论文阅读-2023.07">论文阅读 2023.07</h1><blockquote><p>本文首发于个人博客<br />发表日期：2023.07.31<br />最后编辑于：{docsify-last-updated}</p></blockquote><h2 id="the-multiplayer-colonel-blotto-game">The Multiplayer Colonel Blotto Game</h2><p>文章对经典的上校博弈游戏的自然多人泛化进行了研究。文章定义了多人的上校博弈，同时针对不同的玩家数量<span class="math inline"><em>k</em></span>与战线数量<span class="math inline"><em>n</em></span>导出了纳什均衡。</p><h3 id="上校博弈">上校博弈</h3><p>上校博弈是一个两人参与的零和博弈。</p><p>形式化的，考虑玩家A和B，他们需要在<span class="math inline"><em>n</em></span>个战线中竞争，每个战线俱有价值<span class="math inline"><em>v</em><sub>1</sub>, …, <em>v</em><sub><em>n</em></sub></span>。A和B都有有限的预算<span class="math inline">ℬ<sub><em>A</em></sub></span>、<span class="math inline">ℬ<sub><em>B</em></sub></span>，其可以用于分配在不同战场。他们需要同时决定在每个战场上投入多少预算。对特定战场，在该战场上投入预算较多的一方获胜。玩家的目标是使赢得的战场的价值总和最大化。通常情况下，为了保证对称性（symmetric），会要求<span class="math inline">ℬ<sub><em>A</em></sub> = ℬ<sub><em>B</em></sub>, <em>v</em><sub>1</sub> = … = <em>v</em><sub><em>n</em></sub></span>。</p><p>这一博弈并不存在纯策略纳什均衡。目前对其均衡的多数研究都是根据一般乐透博弈（General Lotto）来计算的。在此博弈中每个玩家在战场上分配的预算是一个分布而非一个数值，而最终目标则是使战场收益期望最大化（或是是单样本收益最大化）。</p><h3 id="多人上校博弈">多人上校博弈</h3><p>文章首先定义了多人上校博弈。</p><p>多人上校博弈由<span class="math inline">$(k\in\mathbb{N},n\in\mathbb{N},\vec{\mathcal{B}}\in\mathbb{R}^n_{\geq0},\vec{v}\in\mathbb{R}^n_{\geq0})$</span>指定。其中<span class="math inline"><em>k</em></span>代表玩家数量，<span class="math inline"><em>n</em></span>代表战场数量，<span class="math inline">$\vec{\mathcal{B}}$</span>是全部玩家预算的向量，<span class="math inline"><em>v⃗</em></span>是战场价值的向量。战场价值总和可以表示为<span class="math inline">$V=\Vert\vec{v}\Vert_1=\sum^n_{j=1} v_j$</span>。</p><p>每个玩家对战场的投标表示为向量<span class="math inline"><em>A</em><sub><em>i</em>, *</sub> = (<em>A</em><sub><em>i</em>, 1</sub>, …, <em>A</em><sub><em>i</em>, <em>n</em></sub>) ∈ ℝ<sub> ≥ 0</sub><sup><em>n</em></sup></span>，其满足约束<span class="math inline">‖<em>A</em><sub><em>i</em>, *</sub>‖<sub>1</sub> = ∑<sub><em>j</em> ∈ [<em>n</em>]</sub><em>A</em><sub><em>i</em>, <em>j</em></sub> ≤ ℬ<sub><em>i</em></sub></span>。</p><p>令投标矩阵为<span class="math inline"><em>A</em> = (<em>A</em><sub><em>i</em>, <em>j</em></sub>)<sub>(<em>i</em>, <em>j</em>) ∈ [<em>k</em>] × [<em>n</em>]</sub></span>（显然第<span class="math inline"><em>i</em></span>行<span class="math inline"><em>j</em></span>列代表<span class="math inline"><em>i</em></span>玩家在<span class="math inline"><em>j</em></span>战场的投标）。对任意<span class="math inline"><em>i</em> ∈ [<em>k</em>]</span>有玩家的收益为：</p><p><br /><span class="math display">$$U_i(A):=\sum_{j\in[n]}U_{i,j}(A):=\sum_{j\in[n]} v_j \cdot (\frac{f(i)}{\vert \argmax_{i'} A_{i',j}\vert})$$</span><br /></p><p>其中： <br /><span class="math display">$$f(i)=\begin{dcases}   1 &amp;\text{if } i \in \argmax_{i' \in [k]} A_{i',j} \\   0 &amp;\text{if } i \notin \argmax_{i' \in [k]} A_{i',j}\end{dcases}$$</span><br /></p><p>换言之每个战场的价值有出价最高的玩家平分。</p><p>论文中将每个玩家预算相同的情况定义为对称（symmetric），将战场价值都相等的情况定位为同质（homogeneous）。</p><h3 id="多人一般乐透博弈">多人一般乐透博弈</h3><p>更一般的，文章定义了多人一般乐透博弈<span class="math inline">$(k\geq2,n,\vec{\mathcal{B}},\vec{v})$</span>，其中玩家<span class="math inline"><em>i</em></span>在战场<span class="math inline"><em>j</em></span>上指定一个分布<span class="math inline">𝒟<sub><em>i</em>, <em>j</em></sub></span>，其满足约束条件<span class="math inline">$\sum^n_{j=1}\mathbb{E}_{A_{i,j}\sim\mathcal{D}_{i,j}}[A_{i,j}]\leq\mathcal{B}_i$</span>。显然此时玩家<span class="math inline"><em>i</em></span>的收益为<span class="math inline">𝔼<sub><em>A</em></sub><em>U</em><sub><em>i</em></sub>(<em>A</em>)</span>。</p><p>考虑连续的对称多人一般乐透博弈，其由<span class="math inline">$(k\geq2,n,\vec{\mathcal{B}}=1,\vec{v})$</span>指定。文章指出，当玩家<span class="math inline"><em>i</em></span>在战场<span class="math inline"><em>j</em></span>上的分布为<span class="math inline">$\mathcal{D}_{i,j}=\frac{kv_j}{V}\cdot Beta(\frac{1}{k-1},1)$</span>时，是一个纳什均衡。</p><h3 id="多人上校博弈均衡算法">多人上校博弈均衡算法</h3><p>基于多人一般乐透博弈的该均衡，文章考虑对称的上校博弈。假如对战场有一个k-分区使得各个分区中战场价值总和相同，那么玩家可以根据特定算法达到纳什均衡。更具体的，计算一个分布<span class="math inline">$(X_1,\dots,X_k)\sim Dir(\frac{1}{k-1},\dots,\frac{1}{k-1})$</span>，那么达到均衡时玩家指定的分布应是<span class="math inline">$(A_1,\dots,A_n),A_j \leftarrow (\frac{kv_j}{V}\cdot X_{\pi(j)})$</span>。</p><p>更具体的，文章还对上述博弈在玩家数<span class="math inline"><em>k</em> = 3</span>时计算了更细致的均衡情况。</p><p>文章最后考虑玩家预算都为整数，且玩家在战场上的投标只为布尔值的情况，并根据前述的结论计算出了这一博弈下的均衡。</p><h2 id="evolutionary-game-theory-squared-evolving-agents-in-endogenously-evolving-zero-sum-games">Evolutionary Game Theory Squared: Evolving Agents in Endogenously Evolving Zero-Sum Games</h2><p><em>没太看懂，看了一下大致内容，可能需要学习下微分几何和动力学以后再看。</em></p><p>进化博弈论的主要范式基于在给定的固定、静态博弈中动态的智能体群体之间的明显差异——也即重复博弈在演化过程中不同类型群体在静态的阶段博弈中所会采取的策略集的差异。文章关注于这样一种情况，即在演化过程中无论是参与博弈的参与者还是博弈本身都会随着时间的推移而演化（类似于神经网络，博弈规则本身可以接收智能体的历史选择与收益来对规则与支付等方面进行改变）。</p><p>文章利用在进化博弈论中最被广泛研究应用的复制器动力学（replicator dynamics，可以粗略地理解为高于平均价值的策略会被模仿）来研究重复的零和博弈。在这一系统之中，智能体群体在零和博弈中竞争的过程中，竞争本身也会对抗性地进化。文章指出，在这一系统中存在多种规律性：</p><ol type="1"><li>该系统遵守信息论守恒定律，其与智能体群体及博弈本身都相关。</li><li>该系统是庞加莱回归的（Poincaré recurrent），包含智能体与博弈本身的系统的所有可能的初始状态都位于循环轨道上。这一系统经过足够长的时间后，会到达一个接近初始态的状态。</li><li>尽管该系统永远无法达到均衡，但智能体的时间平均行为与时间平均效用收敛于演化博弈的时间平均纳什均衡。</li></ol><p>文章最后提供了一种多项式时间算法，来预测任何此类协同演化网络博弈的上述时间平均量。</p><h3 id="多矩阵博弈与复制器动力学定义">多矩阵博弈与复制器动力学定义</h3><p>多玩家的多矩阵博弈以无向图<span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>), |<em>V</em>| = <em>N</em></span>定义，节点集代表玩家的集合，玩家间若进行<span class="math inline">2 × 2</span>矩阵博弈那么代表这两个玩家的节点之间就存在一条边。智能体<span class="math inline"><em>i</em> ∈ <em>V</em></span>利用混合策略以分布<span class="math inline"><em>x</em><sub><em>i</em></sub></span>从决策集<span class="math inline">𝒜<sub><em>i</em></sub> = {1, …, <em>n</em><sub><em>i</em></sub>}</span>种选择决策。其中混合策略集<span class="math inline">𝒳<sub><em>i</em></sub></span>是<span class="math inline">ℝ<sup><em>n</em><sub><em>i</em></sub></sup></span>的标准单形，<span class="math inline">𝒳<sub><em>i</em></sub> = <em>Δ</em><sup><em>n</em><sub><em>i</em></sub> − 1</sup> = {<em>x</em><sub><em>i</em></sub> ∈ ℝ<sub> ≥ 0</sub><sup><em>n</em><sub><em>i</em></sub></sup> : ∑<sub><em>α</em> ∈ 𝒜<sub><em>i</em></sub></sub><em>x</em><sub><em>i</em><em>α</em></sub> = 1}</span>，<span class="math inline"><em>x</em><sub><em>i</em><em>α</em></sub></span>表示玩家<span class="math inline"><em>i</em></span>采取行动<span class="math inline"><em>α</em> ∈ 𝒜<sub><em>i</em></sub></span>的概率质量。理所当然的，博弈的状态以全部玩家策略的连接（concatenation）定义，全部可能的策略配置集合为策略空间<span class="math inline">𝒳 = ∏<sub><em>i</em> ∈ <em>V</em></sub>𝒳<sub><em>i</em></sub></span>。</p><p>边<span class="math inline">(<em>i</em>, <em>j</em>)</span>表示的<span class="math inline">2 × 2</span>矩阵博弈以一对矩阵<span class="math inline"><em>A</em><sup><em>i</em><em>j</em></sup> ∈ ℝ<sup><em>n</em><sub><em>i</em></sub> × <em>n</em><sub><em>j</em></sub></sup></span>与<span class="math inline"><em>A</em><sup><em>j</em><em>i</em></sup> ∈ ℝ<sup><em>n</em><sub><em>j</em></sub> × <em>n</em><sub><em>i</em></sub></sup></span>描述。从定义很显然地可以知道矩阵中的任意一项<span class="math inline"><em>A</em><sub><em>α</em><em>β</em></sub><sup><em>i</em><em>j</em></sup>, ∀(<em>α</em>, <em>β</em>) ∈ 𝒜<sub><em>i</em></sub> × 𝒜<sub><em>j</em></sub></span>表示玩家<span class="math inline"><em>i</em></span>采取策略<span class="math inline"><em>α</em></span>且玩家<span class="math inline"><em>j</em></span>采取策略<span class="math inline"><em>β</em></span>时前者的收益。文中的建模提到在这种系统中允许自环，即允许玩家向自己发起博弈。玩家<span class="math inline"><em>i</em> ∈ <em>V</em></span>在策略配置<span class="math inline"><em>x</em> ∈ 𝒳</span>下的效用/收益<span class="math inline"><em>u</em><sub><em>i</em></sub>(<em>x</em>)</span>显然与该玩家参与的全部博弈中的收益和相关。更具体的，</p><p><br /><span class="math display"><em>u</em><sub><em>i</em></sub>(<em>x</em>) = ∑<sub><em>j</em> : (<em>i</em>, <em>j</em>) ∈ <em>E</em></sub><em>x</em><sub><em>i</em></sub><sup>⊤</sup><em>A</em><sup><em>i</em><em>j</em></sup><em>x</em><sub><em>j</em></sub></span><br /></p><p>文章进一步作了如下定义：<span class="math inline"><em>u</em><sub><em>i</em><em>α</em></sub>(<em>x</em>) = ∑<sub><em>j</em> : (<em>i</em>, <em>j</em>) ∈ <em>E</em></sub>(<em>A</em><sup><em>i</em><em>j</em></sup><em>x</em><sub><em>j</em></sub>)<sub><em>α</em></sub></span>代表玩家<span class="math inline"><em>i</em> ∈ <em>V</em></span>在策略配置<span class="math inline"><em>x</em> = (<em>α</em>, <em>x</em><sub> − <em>i</em></sub>) ∈ 𝒳, <em>α</em> ∈ 𝒜<sub><em>i</em></sub></span>下的效用。如果对全部<span class="math inline"><em>x</em> ∈ 𝒳</span>有<span class="math inline">∑<sub><em>i</em> ∈ <em>V</em></sub><em>u</em><sub><em>i</em></sub>(<em>x</em>)</span>那么博弈是零和的。如果有正系数<span class="math inline">{<em>η</em><sub><em>i</em></sub>}<sub><em>i</em> ∈ <em>V</em></sub></span>使得<span class="math inline">∑<sub><em>i</em> ∈ <em>V</em></sub><em>η</em><sub><em>i</em></sub><em>u</em><sub><em>i</em></sub>(<em>x</em>) = 0</span>对全部<span class="math inline"><em>x</em> ∈ 𝒳</span>都成立，且所有的自环都是反对称的（antisymmetric，<span class="math inline"><em>A</em><sup><em>i</em><em>i</em></sup> =  − (<em>A</em><sup><em>i</em><em>i</em></sup>)<sup>⊤</sup></span>），那么博弈是调节过的零和的（rescaled zero-sum）。</p><p>对<span class="math inline"><em>x</em><sub><em>i</em></sub><sup>*</sup> ∈ 𝒳<sub><em>i</em></sub></span>的支撑<span class="math inline"><em>s</em><em>u</em><em>p</em><em>p</em>(<em>x</em><sub><em>i</em></sub><sup>*</sup>) = {<em>α</em> ∈ 𝒜<sub><em>i</em></sub> : <em>x</em><sub><em>i</em><em>α</em></sub> &gt; 0}</span>，如果<span class="math inline"><em>s</em><em>u</em><em>p</em><em>p</em>(<em>x</em><sub><em>i</em></sub><sup>*</sup>) = 𝒜<sub><em>i</em></sub>, ∀<em>i</em> ∈ <em>V</em></span>，那么<span class="math inline"><em>x</em><sup>*</sup></span>达到的纳什均衡是完全纳什均衡。</p><p>传统的复制器动力学系统被定义为<span class="math inline"><em>ẋ</em><sub><em>i</em><em>α</em></sub> = <em>x</em><sub><em>i</em><em>α</em></sub>(<em>u</em><sub><em>i</em><em>α</em></sub>(<em>x</em>) − <em>u</em><sub><em>i</em></sub>(<em>x</em>)), <em>α</em> ∈ 𝒜<sub><em>i</em></sub></span>（单位时间内采取策略<span class="math inline"><em>α</em></span>的博弈者频率的期望变化量）。为了便于后续计算这一方程可以被简化为如下的矩阵形式：</p><p><br /><span class="math display"><em>ẋ</em><sub><em>i</em></sub> = <em>x</em><sub><em>i</em></sub> ⋅ (∑<sub><em>j</em> : (<em>i</em>, <em>j</em>) ∈ <em>E</em></sub><em>A</em><sup><em>i</em><em>j</em></sup><em>x</em><sub><em>j</em></sub> − (∑<sub><em>j</em> : (<em>i</em>, <em>j</em>) ∈ <em>E</em></sub><em>x</em><sub><em>i</em></sub><sup>⊤</sup><em>A</em><sup><em>i</em><em>j</em></sup><em>x</em><sub><em>j</em></sub>) ⋅ 1)</span><br /></p><p>其中<span class="math inline">1</span>表示全由<span class="math inline">1</span>组成的<span class="math inline"><em>n</em><sub><em>i</em></sub></span>维向量。</p><h3 id="双重进化过程">双重进化过程</h3><p>文章指出，事实上无论是目前热门的机器学习领域还是生物学领域都存在这种智能体与博弈的双重进化过程。在这样的动力系统中，存在随时间演化的被抽样种群，以及取决于这一种群的环境参数。一方面，在AI &amp; ML中，尽管生成器参数一开始就已确定，然而判别器的参数却是随着学习而被更新。生成器与判别器可以被视为遵循进化动力学的群体。另一方面，在生物学领域，无论是研究种群数量的协调水平还是研究资源可用性调节种群间竞争，环境参数都会随时间推移而演变。</p><p>着重考虑物种间竞争资源的动力系统，对于<span class="math inline"><em>n</em></span>个种群中的种群<span class="math inline"><em>i</em> ∈ {1, …, <em>n</em>}</span>，环境变量<span class="math inline"><em>w</em></span>和种群数量<span class="math inline"><em>y</em></span>的单形的内部初始条件有：</p><p><br /><span class="math display">$$\begin{align*}   \dot{w}_i &amp;= w_i\sum^n_{j=1}w_j(y_j-y_i) \\   \dot{y}_i &amp;= y_i((P(w)y)_i-y^{\top}P(w)y)\end{align*}$$</span><br /></p><p>其中<span class="math inline"><em>P</em>(<em>w</em>) = <em>P</em> + <em>μ</em><em>W</em>, <em>μ</em> &gt; 0</span>，<span class="math inline"><em>P</em></span>被定义为一般化的RPS（猜拳）支付矩阵：</p><p><br /><span class="math display">$$P=\begin{pmatrix}0 &amp; -1 &amp; 0 &amp; \dots &amp; 0 &amp; 0 &amp; 1 \\1 &amp; 0 &amp; -1 &amp; \dots &amp; 0 &amp; 0 &amp; 0 \\\dots &amp; \dots &amp; \dots &amp; \dots &amp; \dots &amp; \dots &amp; \dots \\0 &amp; 0 &amp; 0 &amp; \dots &amp; 1 &amp; 0 &amp; -1 \\-1 &amp; 0 &amp; 0 &amp; \dots &amp; 0 &amp; 1 &amp; 0 \end{pmatrix}$$</span><br /></p><p>环境变量矩阵为：</p><p><br /><span class="math display">$$W=\begin{pmatrix}0 &amp; w_1-w_2 &amp;  \dots &amp; w_1-w_n \\w_2-w_1 &amp; 0 &amp; \dots &amp; w_2-w_n \\\dots &amp; \dots  &amp; \dots &amp; \dots \\w_n-w_1 &amp; w_n-w_2 &amp; \dots &amp; 0 \end{pmatrix}$$</span><br /></p><p>文章指出，这一随时间演化的RPS博弈实质上相当于两人调节过的零和博弈中的复制器动力系统。在此基础上，文章进一步作出了规约，并证明能由如下的动力学方程定义的随时间演化的系统都与多矩阵博弈中的复制器动力学系统相同：</p><p><br /><span class="math display">$$\begin{align*}   \dot{w}_{k,i} &amp;= w_{k,i}\sum_{l\in\mathcal{N}^w_k}\sum_j w_{k,j}((A^{k,l}y_l)_i-(A^{k,l}y_l)_j) \\   \dot{y}_{l,i} &amp;= y_{l,i}((P_l(w)y_l)_i-y^{\top}_lP_l(w)y_l)\end{align*}$$</span><br /></p><p>其中<span class="math inline"><em>y</em> = (<em>y</em><sub>1</sub>, …, <em>y</em><sub><em>n</em><sub><em>y</em></sub></sub>)</span>，<span class="math inline"><em>w</em> = (<em>w</em><sub>1</sub>, …, <em>w</em><sub><em>n</em><sub><em>w</em></sub></sub>)</span>。<span class="math inline"><em>y</em><sub><em>l</em></sub> ∈ <em>Δ</em><sup><em>n</em> − 1</sup>, ∀<em>l</em> ∈ {1, …, <em>n</em><sub><em>y</em></sub>}</span>，<span class="math inline"><em>w</em><sub><em>k</em></sub> ∈ <em>Δ</em><sup><em>n</em> − 1</sup>, ∀<em>k</em> ∈ {1, …, <em>n</em><sub><em>w</em></sub>}</span>。环境仅随种群演化，种群紧随环境与种群本身演化。实质上在表示多矩阵博弈的无向图中有自环的节点代表种群，无自环的节点代表博弈本身。前述对于环境变量与种群数量单形初始值的转化实质上分别被视为了代表博弈本身的节点参与的博弈（非自环的边），以及代表种群节点在与自身博弈（自环）中的复制器动态。<span class="math inline">𝒩<sub><em>k</em></sub><sup><em>w</em></sup></span>为与<span class="math inline"><em>w</em><sub><em>k</em></sub></span>一起进化的种群集合，<span class="math inline">𝒩<sub><em>l</em></sub><sup><em>y</em></sup></span>为与<span class="math inline"><em>y</em><sub><em>l</em></sub></span>一起进化的环境集合。<span class="math inline"><em>P</em><sub><em>l</em></sub>(<em>w</em>) = <em>P</em><sub><em>l</em></sub> + ∑<sub><em>k</em> ∈ 𝒩<sub><em>l</em></sub><sup><em>y</em></sup></sub><em>W</em><sup><em>l</em>, <em>k</em></sup>, <em>P</em><sub><em>l</em></sub> ∈ ℝ<sup><em>n</em> × <em>n</em></sup>, <em>W</em><sup><em>l</em>, <em>k</em></sup> ∈ ℝ<sup><em>n</em> × <em>n</em></sup></span>。第<span class="math inline">(<em>i</em>, <em>j</em>)</span>项为<span class="math inline">(<em>A</em><sup><em>l</em>, <em>k</em></sup><em>w</em><sub><em>k</em></sub>)<sub><em>i</em></sub> − (<em>A</em><sup><em>l</em>, <em>k</em></sup><em>w</em><sub><em>k</em></sub>)<sub><em>j</em></sub></span>。</p><p>由于这种简化使得环境变量也可以视为参与博弈的种群，因而这种动态的系统也可以像分析静态博弈中的动态智能体的系统那样进行分析。</p><h3 id="庞加莱回归">庞加莱回归</h3><p>文章接着证明了对有多智能体参与的，具有内部纳什均衡/完全纳什均衡的，调节过的零和多矩阵博弈，这一系统是庞加莱回归的。特别是对于几乎所有初始条件<span class="math inline"><em>x</em>(0) ∈ 𝒳</span>，这一系统将无限次地趋近于接近于<span class="math inline"><em>x</em>(0)</span>的值。事实上，由于在证明过程中需要首先证明保体积（volume preservation）的性质，以及轨道的有界性，而这两者也提示了系统本身的守恒定律。这两者表明系统虽然永远不会达到均衡，但从时间平均的角度上来看，这一系统的动力学特征与效用都与纳什均衡有一定相关性。</p><p>事实上先前已经有研究证明了这一类系统在特定条件（要求全部边都是反对称的）下是庞加莱回归的，而本文则进一步减少了对这些博弈的限制（只有自环必须是反对称的），同时多矩阵博弈本身不要求是严格意义上的零和。</p><h3 id="时间平均行为均衡的计算与有限缺憾">时间平均行为、均衡的计算与有限缺憾</h3><p>文章的理论部分最后证明了这一系统的行为满足了许多理想的博弈论的一致性与最优性标准，并设计了一种用于预测系统行为的多项式时间算法。</p><p>一方面，假如存在唯一的内部纳什均衡/完全纳什均衡，那么复制器动力系统的时间平均轨迹会收敛于纳什均衡，且时间平均效用也会收敛于纳什均衡时的效用。</p><p>另一方面，用于计算与表征零和多矩阵博弈纳什均衡集合的线性规划公式是已知的，文章则将这一结论扩展到了本文先前定义的系统中。考虑一个<span class="math inline"><em>N</em></span>个智能体参与的调节过的零和多矩阵博弈。对于正系数<span class="math inline">{<em>η</em><sub><em>i</em></sub>}<sub><em>i</em> ∈ <em>V</em></sub></span>满足<span class="math inline">∑<sub><em>i</em> ∈ <em>V</em></sub><em>η</em><sub><em>i</em></sub><em>u</em><sub><em>i</em></sub>(<em>x</em>) = 0</span>对全部<span class="math inline"><em>x</em> ∈ 𝒳</span>都成立，那么下面的线性规划方程的最优解就是博弈的纳什均衡：</p><p><br /><span class="math display">$$\min_{x\in\mathcal{X}}\{\sum^n_{i=1}\eta_iv_i\vert v_i\geq u_{i\alpha}(x),\forall i \in V,\forall\alpha\in\mathcal{A}_i\}$$</span><br /></p><p>此外，由于不能整体性地期望存在完全纳什均衡存在，或期望参与者完全理性并遵守相同的学习规则，同时参与者可能也不总能根据已有信息先验地确定均衡策略，故而文章也对忽视其他参与者的玩家的行为作出了评估，即使用“缺憾”的概念。“缺憾”被定义为在<span class="math inline"><em>t</em> ≥ 0</span>的学习路径上选择的混合策略，以及最大化事后效用的静态策略，这两者的时间平均效用的差异。复制器动力系统的这一“缺憾”是有界的。</p><p>通过实验，文章在验证理论证明的同时也发现了一些其他性质。例如，事实上这一系统在自然中是循环的，而不仅仅是庞加莱回归的。通过使用《Cycles in Zero-Sum Differential Games and Biological Diversity》一文中的实验并对其加以复杂化，实验证明这一循环周期是一个相当长的时间。</p><figure><img src="https://pikapikapikaori.github.io/pikapikapi-blog/archive/ITtech/_media/PaperReading-202307-20230701/picture-1.png" alt="" /><figcaption>picture</figcaption></figure><p>如上图，博弈是一个<span class="math inline">8 × 8</span>的多矩阵零和博弈，每个像素点代表一个参与者，像素点的RGB值表示参与者的策略。实验中虽然在前几百次迭代中就已经接近了初始的图像，然而再次能够观察到清晰的图案经过了10万次迭代。</p><h2 id="the-derby-game-an-ordering-based-colonel-blotto-game">The Derby Game: An Ordering-based Colonel Blotto Game</h2><p>传统的上校博弈研究的可互换的资源分配的问题（不同战场可以分配相同资源），而本文则由此延伸，研究不可互换资源的竞争性分配，并将这一类博弈称为德比博弈（Derby Game，说起德比就想到马赛赌马，而文中提到这一命名实质是向田忌赛马致敬）。直觉上来说这一博弈并不存在纯策略纳什均衡，而本文则发现此博弈的纳什均衡存在于一名参与者采取纯策略的情况。</p><h3 id="德比博弈">德比博弈</h3><p>德比博弈由田忌赛马所启发，文中将其形式化地定义为了多元组<span class="math inline">(<em>m</em>, <em>F</em>, <em>G</em>, &gt;,<em>w⃗</em>)</span>，其中<span class="math inline"><em>m</em> ∈ ℕ</span>代表博弈的回合数（轮数），<span class="math inline"><em>F</em></span>和<span class="math inline"><em>G</em></span>分别代表参与者<span class="math inline"><em>A</em></span>和<span class="math inline"><em>B</em></span>的资源组，且有<span class="math inline">|<em>F</em>| = |<em>G</em>| = <em>m</em></span>，<span class="math inline">$&gt;\sube(F\bigcup G)^2$</span>定义了胜利条件，<span class="math inline"><em>w⃗</em> ∈ ℝ<sub> &gt; 0</sub><sup><em>m</em></sup></span>是每回合权重的向量，并且要求<span class="math inline"><em>w</em><sub>1</sub> ≥ <em>w</em><sub>2</sub> ≥ ⋯ ≥ <em>w</em><sub><em>m</em></sub></span>。博弈中两个玩家都以时间顺序进行资源投入。考虑双射<span class="math inline"><em>p</em>: [<em>m</em>] → <em>F</em>, <em>q</em>: [<em>m</em>] → <em>G</em></span>分别将每一轮映射到该轮玩家投入的资源，在第<span class="math inline"><em>i</em></span>轮若<span class="math inline"><em>p</em>(<em>i</em>) &gt; <em>q</em>(<em>i</em>)</span>则<span class="math inline"><em>A</em></span>胜利，反之<span class="math inline"><em>B</em></span>胜利，并获取收益<span class="math inline"><em>w</em><sub><em>i</em></sub></span>，显然有最终的期望收益：</p><p><br /><span class="math display">$$\begin{align*}U_A(p,q) &amp;= \sum^m_{l=1}f[p(i)&gt;q(i)]w_i\\U_B(p,q) &amp;= \sum^m_{l=1} w_i - U_A(p,q)\end{align*}$$</span><br /></p><p>其中函数<span class="math inline"><em>f</em></span>代表导出值<span class="math inline">0, 1</span>的取值函数。注意到这种博弈中最明显的特征是每回合分配一个资源。</p><p>可以很直观地考虑如何将田忌赛马中孙膑的策略应用到每回合权重全相同的德比博弈中，当另一个参与者的资源投入顺序已经确定的情况下，假设存在常数<span class="math inline"><em>K</em> ∈ [<em>m</em>]</span>用于，那么应当用最佳的资源去对抗玩家<span class="math inline"><em>B</em></span>的第<span class="math inline"><em>m</em> − <em>K</em> + 1</span>佳资源，并以此类推知道用第<span class="math inline"><em>K</em></span>佳资源对抗<span class="math inline"><em>B</em></span>的最差资源，在这种情况下可以赢得<span class="math inline"><em>K</em></span>轮，并输掉剩余的<span class="math inline"><em>m</em> − <em>K</em></span>轮，在这一策略中目标应是使得常数<span class="math inline"><em>K</em></span>尽可能大。稳重证明这种资源投入策略也能提供比任何其他投入策略下获得收益都更多的最终收益（换言之此时最终获得的收益最多，可以取等号）。</p><h3 id="每回合权重都相同的德比博弈">每回合权重都相同的德比博弈</h3><p>首先需要说明，德比博弈中的纯策略对应于参与者所选择的资源投入顺序（schedule），而混合策略则对应于在这一投入顺序上的分布。</p><p>考虑每回合权重都相同的德比博弈，文中证明在此中博弈中并不存在强/弱优势策略（strictly/weakly dominant strategies）。并由此进一步推演发现，这一类博弈都含有纳什均衡，其中每位参与者在资源投入顺序上的分布都是均匀的。</p><p>为了分析均衡的特征，文中重新引入可互换性的定义。考虑<span class="math inline"><em>A</em></span>和<span class="math inline"><em>B</em></span>的资源<span class="math inline"><em>A</em><sub>1</sub> &gt; <em>B</em><sub>1</sub> &gt; <em>B</em><sub>2</sub> &gt; <em>B</em><sub>3</sub> &gt; <em>A</em><sub>3</sub></span>，那么在博弈中<span class="math inline"><em>B</em><sub>1</sub>, <em>B</em><sub>2</sub>, <em>B</em><sub>3</sub></span>三类资源实质上是可以视为相等的。由此可以将<span class="math inline"><em>F</em>, <em>G</em></span>划分为等价类的集合：<span class="math inline"><em>A</em><sub>1</sub>⋃⋯⋃<em>A</em><sub><em>n</em><sub>1</sub></sub> = <em>F</em>, <em>B</em><sub>1</sub>⋃⋯⋃<em>B</em><sub><em>n</em><sub>2</sub></sub> = <em>G</em></span>，同时也可以讲博弈中定义的获胜条件关系进一步扩展到集合上，对集合<span class="math inline"><em>C</em><sub><em>x</em></sub>, <em>C</em><sub><em>y</em></sub> ∈ {<em>A</em><sub>1</sub>, ⋯, <em>A</em><sub><em>n</em><sub>1</sub></sub>, <em>B</em><sub>1</sub>, ⋯, <em>B</em><sub><em>n</em><sub>2</sub></sub>}</span>，<span class="math inline"><em>C</em><sub><em>x</em></sub> &gt; <em>C</em><sub><em>y</em></sub></span>表示<span class="math inline"><em>C</em><sub><em>x</em></sub></span>中的任意资源都优于<span class="math inline"><em>C</em><sub><em>y</em></sub></span>中的全部资源。</p><p>通过这种引入可互换性的方法，德比博弈可以重新以多元组<span class="math inline">(<em>m</em>, <em>n</em>, <em>A⃗</em>, <em>V⃗</em>, <em>w⃗</em>)</span>来表示，其中<span class="math inline"><em>m</em>, <em>w⃗</em></span>的定义不变，<span class="math inline"><em>n</em> ∈ ℕ</span>表示集合<span class="math inline"><em>F</em>, <em>G</em></span>被划分为的子集合数量，<span class="math inline"><em>A⃗</em> = (<em>A</em><sub>1</sub>, ⋯, <em>A</em><sub><em>n</em></sub>), <em>B⃗</em> = (<em>B</em><sub>1</sub>, ⋯, <em>B</em><sub><em>n</em></sub>)</span>分别为子集合的向量，<span class="math inline"><em>A</em><sub>1</sub>, <em>B</em><sub><em>n</em></sub></span>可以为空集，<span class="math inline"><em>A</em><sub>1</sub> &gt; <em>B</em><sub>1</sub> &gt; <em>A</em><sub>2</sub> &gt; <em>B</em><sub>2</sub> &gt; ⋯ &gt; <em>A</em><sub><em>n</em></sub> &gt; <em>B</em><sub><em>n</em></sub></span>。</p><p>由于这一类可互换性的特性，德比博弈可以被视为上校博弈的变体。文中进一步定义了有效策略：<span class="math inline"><em>A</em></span>和<span class="math inline"><em>B</em></span>的有效策略被定义为<span class="math inline"><em>m</em> × <em>n</em></span>的矩阵<span class="math inline"><em>P</em>, <em>Q</em> ∈ [0, 1]<sup><em>m</em> × <em>n</em></sup></span>，其中：</p><ul><li>每个单元格<span class="math inline"><em>P</em><sub><em>i</em><em>x</em></sub>, <em>Q</em><sub><em>i</em><em>x</em></sub></span>代表第<span class="math inline"><em>i</em></span>轮中使用（<span class="math inline"><em>A</em></span>或<span class="math inline"><em>B</em></span>）的第<span class="math inline"><em>x</em></span>个等价类的边际概率</li><li><span class="math inline">$\forall x.\ \sum^m_{i=1} P_{ix} = a_x = \vert A_x\vert,\sum^m_{i=1} Q_{ix} = b_x = \vert B_x\vert$</span></li><li><span class="math inline">$\forall i.\ \sum^n_{x=1} P_{ix}=1, \sum^n_{x=1} Q_{ix}=1$</span></li></ul><p>显然有<span class="math inline">$U_A(P,Q)=\sum^m_{i=1}\sum^n_{x=1}\sum^n_{y=x}w_iP_{ix}Q_{iy}$</span>。</p><p>实质上这一定义抽象了游戏中的混合策略。每个混合策略都被映射到有效策略，且每个有效策略至少对应一个混合策略。值得注意的是，当矩阵中每格都取值<span class="math inline">0, 1</span>时代表纯（有效）策略，取值<span class="math inline">[0, 1]</span>则代表混合（有效）策略。</p><p>进一步的，有效均匀策略（effectively uniform strategy）要求有效策略中概率的分布与等价类大小成正比。换言之，对<span class="math inline"><em>U</em><em>n</em><em>i</em><em>f</em><em>o</em><em>r</em><em>m</em>(<em>A⃗</em>), <em>U</em><em>n</em><em>i</em><em>f</em><em>o</em><em>r</em><em>m</em>(<em>B⃗</em>) ∈ [0, 1]<sup><em>m</em> × <em>n</em></sup></span>，<span class="math inline">$Uniform(\vec{A})=\frac{a_x}{m},Uniform(\vec{B})=\frac{b_x}{m}$</span>。由此文中证明，每回合权重都相同的德比博弈中，唯一的纳什均衡存在当且仅当两个参与者都采取有效均匀策略。</p><p>对于每回合权重都相同的德比博弈，若至少一位参与者仅有一个有效策略时，称其为平凡的（trivial），这发生于有一个参与者仅有一个资源的等价类的情况。对于全部非平凡的每回合权重都相同的德比博弈，当一个参与者采取纯（有效）策略时存在纳什均衡。</p><h3 id="更一般的德比博弈">更一般的德比博弈</h3><p>如同很多其他研究一样，文中又研究了二元德比博弈（这一类二元情况下的博弈通常被认为是最简单的，可以简化研究），随后再推广到更一般的，有权重的德比博弈。对于二元德比博弈，其意味着每个参与者都有两个等价类。文中研究了二元德比博弈中的一些纳什均衡的特征，并将其推广到了更一般的形式。</p><h2 id="the-competition-complexity-of-dynamic-pricing">The Competition Complexity of Dynamic Pricing</h2><p>本文研究了单物品拍卖下动态定价对最优拍卖的竞争复杂性。更具体的，本文考虑了先知不等式（prophet inequality）语境下，将从分布<span class="math inline"><em>F</em></span>中导出的<span class="math inline"><em>m</em></span>个独立同分布（<span class="math inline"><em>i</em>.<em>i</em>.<em>d</em></span>）随机变量的最优在线策略（optimal online policy）可实现的预期收益<span class="math inline"><em>A</em><sub><em>m</em></sub>(<em>F</em>)</span>，与从相同分布导出的<span class="math inline"><em>n</em></span>个独立同分布随机变量的预期最大值<span class="math inline"><em>M</em><sub><em>n</em></sub>(<em>F</em>)</span>进行了比较（由于是与最优拍卖进行比较，因而只需要考虑最大值），并对于给定的<span class="math inline"><em>ϵ</em> ≥ 0, <em>n</em></span>，试图计算最小的<span class="math inline"><em>m</em> ≥ <em>n</em></span>，使得<span class="math inline">∀<em>F</em>. (1 + <em>ϵ</em>)<em>A</em><sub><em>m</em></sub>(<em>F</em>) ≥ <em>M</em><sub><em>n</em></sub>(<em>F</em>)</span>。注意最优在线策略由逆向归纳法发现，同时<span class="math inline"><em>m</em></span>对<span class="math inline"><em>n</em>, <em>ϵ</em></span>的函数依赖（functional dependence）被定义为动态定价的竞争复杂性。其中<span class="math inline"><em>ϵ</em> = 0</span>被称为精确竞争复杂性，而<span class="math inline"><em>ϵ</em> &gt; 0</span>被称为其的近似版本。</p><p>本文的结论：</p><ol type="1"><li><span class="math inline"><em>ϵ</em> = 0</span>时，对任何<span class="math inline"><em>m</em>, <em>n</em></span>，都存在分布<span class="math inline"><em>F</em></span>使得<span class="math inline"><em>A</em><sub><em>m</em></sub>(<em>F</em>) &lt; <em>M</em><sub><em>n</em></sub>(<em>F</em>)</span>，也即竞争复杂性是无界的的。</li><li>对任何<span class="math inline"><em>ϵ</em> &gt; 0</span>，有<span class="math inline"><em>m</em> = <em>ϕ</em>(<em>ϵ</em>)<em>n</em></span>是<span class="math inline">$\phi(\epsilon)=\Theta(\log\log\frac{1}{\epsilon})$</span>的充要条件。换言之只要<span class="math inline"><em>m</em> ≥ <em>ϕ</em>(<em>ϵ</em>)<em>n</em></span>，就有<span class="math inline">∀<em>F</em>. (1 + <em>ϵ</em>)<em>A</em><sub><em>m</em></sub>(<em>F</em>) ≥ <em>M</em><sub><em>n</em></sub>(<em>F</em>)</span>。</li></ol><p>更形象的理解，考虑一个拍卖，如果按照传统的最优拍卖，那么当有<span class="math inline"><em>n</em></span>竞拍者时最优拍卖应当能使得卖家能够获得最大的预期收入，此时成交价也是竞拍者中的最大价格（相当于一价拍卖）。而如果采取动态定价，换言之多个竞拍者可以多次有顺序地出价，那么这将使得博弈变为经典的先知不等式问题。本文则考虑动态定价下使得最终期望收入满足特定条件的最小的出价轮数<span class="math inline"><em>m</em></span>值。</p><h2 id="efx-exists-for-three-agents">EFX Exists for Three Agents</h2><p>本文着眼于三个参与者间的EFX分配问题，并证明在三个参与人间始终存在EFX分配。同时，本文也证伪了另一篇论文的猜想，表明不存在有效的完整EFX配置。</p><p><em>EFX分配：EF分配（Envy-free item allocation）指对两个参与者A与B，其拥有的物品束分别为X和Y。EF分配指对任何参与者，其认为其持有的物品束的价值总和不小于另一个参与人的物品束价值总和。EFX分配则指当从某一个参与人的物品束中移除任意一个物品后可以使得另一个参与人无嫉妒。</em></p><p><em>部分EFX分配：部分指明不是全部物品都需要被分配给参与者。</em></p><p><em>纳什社会福利（Nash social welfare）：当满足帕累托最优，社会福利函数不依赖于个体，匿名性与连续性的情况下，可以导出的特殊的社会福利函数即为纳什社会福利函数。注意这里社会福利函数可以被视为个人福利的总和，个人福利以效用水平表示。</em></p><p>对于前者，本文中给出了一系列的进行分配的步骤，并表明了这一分配是逐渐在向EFX分配趋近，并最终能达到EFX分配。注意到本文实质上关注于参与人的估值函数是简单的可加性函数的情况，还未推及到更一般的估值函数。</p><p><em>可加性估值函数：表明对商品束而言，商品束的估价可以被视为商品束内全部商品估价的总和。</em></p><p>而后者实质上可以说是从前者衍生而得到的推论之一。</p><h2 id="one-dollar-each-eliminates-envy">One Dollar Each Eliminates Envy</h2><p>本文着眼于研究<span class="math inline"><em>m</em></span>个不可分割的商品在<span class="math inline"><em>n</em></span>个代理人间进行无嫉妒分配的问题。当然通常这是不可能的，但是可以通过引入一定数量的可分割商品来达到EF分配。本文证明给予每个代理人最多一美元（一个单位价值）的补贴就足以保证EF分配存在，且补贴总和最多为<span class="math inline"><em>n</em> − 1</span>单位价值。此时，这种分配同时也是EF1的，且这种分配是平衡的，换言之分配的束的数量最多差一。同时本文还证明，对于一般的单调估价函数，始终存在EF分配使得每个代理人最多获得<span class="math inline">2(<em>n</em> − 1)</span>单位价值的补贴，此时补贴总和为<span class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span>。注意这里的估价函数都为可加性函数。</p><p><em>个人感觉结论直觉上还挺显然的，最大的价值可能在于证明了补贴可以足够小。</em></p><p>分配算法首先从代理人集合<span class="math inline"><em>I</em></span>和商品束<span class="math inline"><em>J</em></span>中导出<span class="math inline"><em>I</em>, <em>J</em></span>上的完全二分图，其中边的权重为代理人对商品的估值。算法递归地从完全二分图的子图中寻找最大的权重的边（匹配），并将对应的商品分配给代理人。</p><figure><img src="https://pikapikapikaori.github.io/pikapikapi-blog/archive/ITtech/_media/PaperReading-202307-20230701/picture-2.png" title="分配算法" alt="" /><figcaption>picture</figcaption></figure><p>注意算法中有<span class="math inline"><em>j</em> = <em>μ</em><sub><em>i</em></sub><sup><em>t</em></sup></span>的记法，<span class="math inline">𝒜</span>为指明分配的集合。本文接着即证明了这种分配算法最终能达到EF与EF1，并接着证明了这种分配方式可以使得商品的边界价值不大于<span class="math inline">1</span>（注意为了简化计算，全部的估价在最初被转化为了不大于<span class="math inline">1</span>的等价值）。而由于至多只有<span class="math inline"><em>n</em> − 1</span>个代理人需要附加的补贴，因而可以保证补贴综合最多为<span class="math inline"><em>n</em> − 1</span>。</p><p>本文在最后的部分考虑更一般的情况，即估价函数为更一般的单调函数，而并不要求严格的可加性，并试图证明此时补贴总和至多为<span class="math inline">2(<em>n</em> − 1)<sup>2</sup></span>（与<span class="math inline"><em>m</em></span>无关）。由于分配算法试图先找到满足要求的EF1分配，再将其进一步转化为EF分配，在此过程中本文发现补贴总和至多只需要<span class="math inline">2(<em>n</em> − 1)</span>。</p><h2 id="参考资料">参考资料</h2><h3 id="参考文献阅读的论文按文中序">参考文献（阅读的论文，按文中序）</h3><ol type="1"><li>Enric Boix-Adserà, Benjamin L. Edelman, and Siddhartha Jayanti. 2020. The Multiplayer Colonel Blotto Game. In Proceedings of the 21st ACM Conference on Economics and Computation (EC ’20). Association for Computing Machinery, New York, NY, USA, 47–48. https://doi.org/10.1145/3391403.3399555</li><li>Skoulakis, S., Fiez, T., Sim, R., Piliouras, G., &amp; Ratliff, L. (2021, May 18). Evolutionary Game Theory Squared: Evolving Agents in Endogenously Evolving Zero-Sum Games. Proceedings of the AAAI Conference on Artificial Intelligence, 35(13), 11343–11351. https://doi.org/10.1609/aaai.v35i13.17352</li><li>Gaonkar, A., Raghunathan, D., &amp; Weinberg, S. M. (2022, July 12). The Derby Game: An Ordering-based Colonel Blotto Game. Proceedings of the 23rd ACM Conference on Economics and Computation. https://doi.org/10.1145/3490486.3538367</li><li>Brustle, J., Correa, J., Dütting, P., &amp; Verdugo, V. (2022, July 12). The Competition Complexity of Dynamic Pricing. Proceedings of the 23rd ACM Conference on Economics and Computation. https://doi.org/10.1145/3490486.3538366</li><li>Chaudhury, B. R., Garg, J., &amp; Mehlhorn, K. (2020, July 13). EFX Exists for Three Agents. Proceedings of the 21st ACM Conference on Economics and Computation. https://doi.org/10.1145/3391403.3399511</li><li>Brustle, J., Dippel, J., Narayan, V. V., Suzuki, M., &amp; Vetta, A. (2020, July 13). One Dollar Each Eliminates Envy. Proceedings of the 21st ACM Conference on Economics and Computation. https://doi.org/10.1145/3391403.3399447</li></ol><h3 id="其他资料">其他资料</h3><ol type="1"><li>Kovenock, D., &amp; Roberson, B. (2020, June 20). Generalizations of the General Lotto and Colonel Blotto games. Economic Theory, 71(3), 997–1032. https://doi.org/10.1007/s00199-020-01272-2</li><li>Recurrence and Topology. (2007, July 30). https://doi.org/10.1604/9780821842348</li><li>Mai, T., Mihail, M., Panageas, I., Ratcliff, W., Vazirani, V., &amp; Yunker, P. (2018, June 11). Cycles in Zero-Sum Differential Games and Biological Diversity. Proceedings of the 2018 ACM Conference on Economics and Computation. https://doi.org/10.1145/3219166.3219227</li><li>Kaneko, M., &amp; Nakamura, K. (1979, March). The Nash Social Welfare Function. Econometrica, 47(2), 423. https://doi.org/10.2307/1914191</li></ol>]]></content>
    <pubDate>Sat, 13 Apr 2024 14:30:34 +0800</pubDate>
  </entry>
  
</channel>
</rss>
